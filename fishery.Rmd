---
title: "Fishery Model"
date: "`r Sys.Date()`"
output: html_document
---

```{r pkg_ins, include= FALSE, warning = FALSE, message = FALSE}

rm(list=ls())

# Check out knitr for knitr::read_chunk.
library(knitr)

# Name packages.
pkg <- c("readr",
         "knitr",
         "tidyverse",
         "gapminder",
         "sandwich",
         "broom",
         "stargazer",
         "cowplot",
         "kableExtra",
         "reshape2",
         "devtools")

# Install packages.
#install.packages(pkg, verbose = FALSE, quiet = TRUE)
#devtools::install_github("AckerDWM/gg3D")
  
# Update packages.
#update.packages(pkg, verbose = FALSE, quiet = TRUE)

# Check out packages.
invisible(lapply(pkg, library, character.only = TRUE))

#library(gg3D)

```

###Objective: Step through optimal aggregate harvest in an open access fishery.
1. Replicate INAPESCA's population model. 
2. Adapt methods to a 10-year forecast.
3. Add price-sensitive effort under open access.
4. Parameterize the model over historic recruitment, stock, and catch data.

 * Each component requires specification of a function from available data and existing models.
  + Right now, each component is specified as a vector, which is convenient but not adequate for what we're doing.
  + Turning everything into functions, or keeping things as functions instead of vectors, is the next step for more complex loops.

####1. Population Model

#####a. Initial Numbers at Age
* Build an initial age structure - numbers at age - from using INAPESCA's median biomass estimate for 2017 and True's function for a stable age structure.
 + Structure from True (2018).
 
$N_a = 121.99 * 10^{-0.214a}$

```{r ninit}

# Vector for initial n at a.
#  Assign initial biomass from INAPESCA estimate.
#  Try the lower bound on the 95% CI of INAPESCA's 2017 estimate from surveys.
biomass_init = 32399000 # median biomass estimate from INAPESCA (2018) in kilograms.

#  Assign functional form for frequencies at age from True (2018). See notes on symposium presentation. Check whether curve describes numbers at age.
#fun_a_n = function(a){121.99 * 10 ^ (-0.214 * a)}
# Alternative distribution for tests.
fun_a_n = function(a){121.99 * 10 ^ (-0.09 * a)} # Number's made-up for fun and plausibility tests.

#  Convert numbers at age to sums of weights at age to work from total biomass back to numbers at age.
fun_a_l = function(a, linf, k, t0){l = linf * (1 - exp(-k * (a - t0)))} # INAPESCA (2018): 200, 0.155, -0.65. See notes for alternatives.
fun_l_w = function(a, l, b){w = a * l ^ b} # INAPESCA (2018) / Anda-Montañez et al. (2013): 0.000005, 3.0635. See notes for alternatives.

# Calculations:
#  Vector of ages.
a = seq(1, 27)
#  Vector of lengths.
l = fun_a_l(a, 200, 0.155, -0.65)
#  Vector of weights.
#w = fun_l_w(0.000005, l, 3.0635) This is a wrong thing that makes your numbers bad and wrong.
w = fun_l_w(0.000004128, l, 3.24674) # This is a right thing that makes your numbers good and right.
#  Numbers at age.
afreq = fun_a_n(a)
#  Weights at age.
wfreq = afreq * w
#  Weights at age, but useful.
winit = wfreq * (1 / sum(wfreq)) * biomass_init
#  Numbers at age to seed the model.
ninit = winit / w

```

#####b. Natural Mortalities
* Build constant survival after natural mortality at age. 

Total Mortality at Age:
$N_a = N_0e^{-M_a}$

Marginal Mortality at Age:
$N_a = N_{a-1}e^{-M_a}$

```{r nmort}

# Function for proportional marginal survival at age. From INAPESCA (2018) / Cisneros-Mata et al. (1995).
fun_a_mort = function(n, m){s = n * exp(-m)}

m = 0.26 # Also from INAPESCA (2018) / Cisneros-Mata et al. (1995).

```

#####c. Poaching Mortalities
* Build poaching mortalities at age from INAPESCA data. 
+ Instead of using numbers from 2016 - 2017, sums by age are taken over all years of sampling for a higher *n*.
+ Whether this is the best option is open to debate and guidance from advisors.
+ The function fit to mortalities-at-age is a Weibull probability density function. *Alternative functions were not tested.*

+ $f(a) = x \frac{\beta}{\eta} (\frac{T - \gamma}{\eta})^{\beta - 1}e^{-(\frac{T - \gamma}{\eta})^{\beta}}$

```{r fishing, echo = FALSE, warning = FALSE}
# Vector for proportional poaching mortalities at age.
#  Read in values for size-selective poaching from INAPESCA (2018); n = 1147 from 9 periods, 1963 - 2017.
v_select_data = 
  c(6, 9, 15, 60, 191, 281, 165, 133, 82, 33, 27, 21, 17, 10, 12, 16, 8, 15, 9, 12, 7, 9, 5, 2, 2, 0) %>% 
  data.frame() %>% 
  mutate(age = seq(1, 26)) %>% 
  rename(n = ".")

#  Estimate fit for a Weibull probability density function. Try weibull.com/hotwire/issue14/relbasics14.htm
nls_select = nls(v_select_data$n ~ ifelse(is.na(x * (a / b) * ((v_select_data$age - c) / b) ^ (a - 1) * exp(-((v_select_data$age - c) / b ) ^ a)),
                                          0,
                                          x * (a / b) * ((v_select_data$age - c) / b) ^ (a - 1) * exp(-((v_select_data$age - c) / b ) ^ a)),
                 v_select_data, 
                 start = list(x = 3000, a = 2.5, b = 10, c = -3), 
                 lower = list(0, 0, 0, -Inf),
                 algorithm = "port")

#  Tibbulate nonlinear estimation.
nls_tidy = tidy(nls_select)

#  Plot fit against actual values.
fun_select = function(x, a, b, c, t){n = ifelse(is.na(x * (a / b) * ((t - c) / b) ^ (a - 1) * exp(-((t - c) / b ) ^ a)),
                                                0,
                                                x * (a / b) * ((t - c) / b) ^ (a - 1) * exp(-((t - c) / b ) ^ a))
                                     return(n)}

v_select_fit = fun_select(nls_tidy$estimate[1], nls_tidy$estimate[2], nls_tidy$estimate[3], nls_tidy$estimate[4], seq(1, 26))

#  Use parameters to restate the function on a single dimension (age) for integration.
simple_fun_select = function(t){n = 
                                ifelse(is.na(nls_tidy$estimate[1] * (nls_tidy$estimate[2] / nls_tidy$estimate[3]) * ((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3]) ^ (nls_tidy$estimate[2] - 1) * exp(-((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3] ) ^ nls_tidy$estimate[2])),
                                0,
                                nls_tidy$estimate[1] * (nls_tidy$estimate[2] / nls_tidy$estimate[3]) * ((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3]) ^ (nls_tidy$estimate[2] - 1) * exp(-((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3] ) ^ nls_tidy$estimate[2]))
                                return(n)}

#  Integrate over ages of interest.
int_select = integrate(simple_fun_select, lower = 0, upper = 27)

#  Transform fitted values for poaching selectivity into a probability distribution function using the integral of the unidimensional function.
fun_poach = function(t){n = ifelse(is.na((nls_tidy$estimate[1] / int_select$value) * (nls_tidy$estimate[2] / nls_tidy$estimate[3]) * ((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3]) ^ (nls_tidy$estimate[2] - 1) * exp(-((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3] ) ^ nls_tidy$estimate[2])), 
                                    0, 
                                    (nls_tidy$estimate[1] / int_select$value) * (nls_tidy$estimate[2] / nls_tidy$estimate[3]) * ((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3]) ^ (nls_tidy$estimate[2] - 1) * exp(-((t - nls_tidy$estimate[4]) / nls_tidy$estimate[3] ) ^ nls_tidy$estimate[2]))}

plot_weib =
ggplot() + 
  geom_line(aes(seq(1, 26, by = 0.01), simple_fun_select(seq(1, 26, by = 0.01))), color = "Firebrick4") + 
  geom_point(aes(seq(1, 26), v_select_data$n)) +
  labs(x = "Age", y = "Catch") +
  theme_classic()

print(plot_weib)

#  Consider fixing the upper tail. Those residuals probably matter.

#  Transform 2017 catch into 2017 catch-at-age in weight, then transform that sucker into catch-at-age in numbers, then make it proportions again.
#  Make this comment better.
#catch = 1400000 # kilograms from tonnes. INAPESCA (2018).
#v_select_n = catch * v_select_pdf / w # Check your conversion! You did this in the middle of the night, check it!
#v_select_use = v_select_n/ninit # Diagnostic plot indicates you should really, really fix the residuals on the selectivity estimation.

```

Variable   | Definition                          | Value
---------- | ----------------------------------- | ---------------------------
*f*        | Poaching Mortality                  |
*a*        | Age                                 |
*x*        | Scale Parameter (1)                 | `r nls_tidy$estimate[1]`
$\beta$    | Weibull Slope (Shape Parameter)     | `r nls_tidy$estimate[2]`
$\eta$     | Scale Parameter (2)                 | `r nls_tidy$estimate[3]`
$\gamma$   | Location Parameter                  | `r nls_tidy$estimate[4]`

#####d. Bycatch Mortalities
* Build bycatch mortalities at age from INAPESCA data.
+ These are proportions at age, but since INAPESCA's data is a narrow spread around one year of age, it's easiest to just make bycatch a proportion of juveniles at one age.
+ Since this is a constant value, it's not stored in a function.

```{r bycatch}

# Value for proportional bycatch mortalities at age.
bymort = 1 - 80000 / ninit[2] # Instead of distributing bycatch mortalities, we concentrate them on one age (2) for lack of length-at-age resolution. 
                              # INAPESCA (2018) - estimated for 2011 - 2017.

```

#####e. Reproduction
* Build reproduction from INAPESCA estimates of maturation and egg production by weight.

Maturation at Length | INAPESCA (2018)

$r(l) = (1+e^{\alpha(l-\beta))^{-1}}$ 

Variable   | Definition                          | Value
---------- | ----------------------------------- | ---------------------------
*r*        | Proportion of Mature Females        |
*l*        | Length (millimeters)                |
$\alpha$   | Parameter                           | 0.0099
$\beta$    | Length for $r = 50$                 | 1333.31

Egg Production at Weight | INAPESCA (2018), Valenzuela-Quiñonez (2014)

$e(w) = \alpha e^{\beta w}$ 

Variable   | Definition                          | Value
---------- | ----------------------------------- | ---------------------------
*e*        | Egg Production                      |
*a*        | Age                                 |
*w*        | Weight                              |
$\alpha$   | Parameter                           | 221.76
$\beta$    | Parameter                           | 0.0047

Survival (Egg-Juvenile) | INAPESCA (2018), CREMES (201?)

Stage               | Proportional Survival
------------------- | ----------------------
*Viable Eggs*       | 0.70
*Fertilized Eggs*   | 0.90
*Hatched Larvae*    | 0.95
*Successful Larvae* | 0.10 

Total Recruitment | INAPESCA (2018), Shepherd (1982)

$N_{0, t} = \frac{\alpha N_{a, t-1}}{[1 + (N_{a, t-1} / \beta)]^{\delta}}$

Variable   | Definition                          | Value
---------- | ----------------------------------- | ---------------------------
$N_{0, t}$ | Recruits                            |
$N_{a, t}$ | Cohort of Age *a*                   |
$\alpha$   | Parameter                           | 131.35
$\beta$    | Parameter                           | 3.07
$\delta$   | Parameter                           | 1.639951478

```{r recruitment}

fun_mat = function(a, l, a_mat, b_mat){r = 1 / (1 + exp(a_mat * (l * 10 - b_mat)))} # Proportion of mature females.
  
fun_egg = function(a, l, w, n, r, a_egg, b_egg){e = n * w * r * a_egg * exp(b_egg * l * 10)} # Egg production.
  
fun_sur = function(e, a_sur, b_sur, c_sur, d_sur){s = e * a_sur * b_sur * c_sur * d_sur} # Survival from egg to juvenile.

fun_rec = function(n, a_rec, b_rec, d_rec){n0 = (a_rec * n) / ((1 + n / b_rec) ^ d_rec)} # Total recruitment. Use this one.

```

#####f0.5. Parameters

With intermediate results ready to plug into the Faustmann model, everything goes into a vector for model runs and a table for handy external reference.

```{r pars, eval = FALSE, include = FALSE}

# Define parameters for each low-level function in a high-level function of multiple harvests over time.
var = c("rows",
        "cols",
        "biom_init",
        "a_ninit",
        "b_ninit",
        "linf",
        "k,",
        "t0",
        "a_lw",
        "b_lw",
        "m",
        "x_f",
        "b_f",
        "n_f",
        "y_f",
        "bymort",
        "a_rec",
        "b_rec",
        "d_rec")

par = c(10, 
        27,
        200,
        32399000,
        121.99,
        -0.09,
        0.155,
        -0.65,
        0.000005,
        3.0635,
        0.26,
        974.4340378,
        1.745196,
        3.1966691,
        3.8386018,
        0.60,
        131.35,
        3.07,
        1.639951478)

units = c("Years",
          "Years",
          "Kilograms",
          "-",
          "-",
          "Centimeters",
          "Years (Inverse)",
          "Years",
          "-",
          "-",
          "-",
          "-",
          "-",
          "-",
          "-",
          "%",
          "-",
          "-",
          "-")

fun = c(rep("All", 2),
        rep("Initial Age Distribution", 3),
        rep("Von Bertalanffy", 3),
        rep("Weight-Length", 2),
        "Natural Mortality",
        rep("Poaching Selectivity", 4),
        "Bycatch Mortality",
        rep("Recruitment", 3))

num = seq(1, length(var))

tab = data.frame(num, fun, var, par)

# Save parameters to working directory.
#kable(tab, digits = 2) %>%
#  kable_styling() %>%
#  save_kable(file = "partab.html", self_contained = T)

```

#####f. Iteration

* Model w/ loops and functions.

```{r hoof, eval = FALSE, include = FALSE}

# Set up the whole damn thing. Template.
fi = function(par){counts = matrix(nrow = par[1], ncol = par[2])
                   e = as.numeric(vector(length = par[1]))
                   counts[1,] = seq(1, par[2])
                   e[1] = 5
                   
                   for(i in 2:par[1]){
                     for(j in 2:par[2]){
                     e[i] = e[i - 1] + 1
                     counts[i, j] = counts[i - 1, j - 1] + e[i - 1]
                     }
                   counts[i, 1] = sum(counts[i - 1, 2:par[2]])
                   }
                   
                   return(counts)
                   
                   }

# Set up the whole damn thing, but really this time.
# NB: This is still far from working - refer to the mock-up above for the basic nested loop structure. That one does work.
fi = function(par){
                   # Build objects to fill.
                   n = matrix(nrow = par[1], ncol = par[2]) # Build a matrix of numbers at age.
                   m = matrix(nrow = par[1], ncol = par[2]) # Build a matrix of natural mortalities at age.
                   b = matrix(nrow = par[1], ncol = par[2]) # Build a matrix of bycatch at age.
                   y = matrix(nrow = par[1], ncol = par[2]) # Build a matrix of catch at age.
                   r = as.numeric(vector(length = par[1]))  # Build a vector of recruitment at age.
                   e = as.numeric(vector(length = par[1]))  # Build a vector of effort. This is the variable for optimization in the economic component.
                   r = as.numeric(vector(length = par[1]))  # Build a vector of total revenues.
                   c = as.numeric(vector(length = par[1]))  # Build a vector of total costs.
                   
                   # Add initial values.
                   n[1,] = ninit # Age distribution for first year, e.g. 2017.
                   m[1,]
                   b[1,] = 1 # Bycatch survival by cohort for first year.
                   b[1, 2] = n[1, 2] * par[16] # Bycatch survival for the single cohort affected by bycatch for first year.
                   y[1,] = # Catch by cohort for first year.
                   r[1] = fun_rec(sum(n[1, 2:par[2]]), par[17], par[18], par[19]) # Recruitment for first year.
                   e[1] = 5 # Effort for first year.
                   r[1] = 5 # Revenues for first year.
                   c[1] = 5 # Costs for first year.
                   
                   # Loop through the period of interest.
                   for(i in 2:par[1]){
                     for(j in 2:par[2]){
                     e[i] = e[i - 1] + 1
                     n[i, j] = counts[i - 1, j - 1] + e[i - 1]
                     }
                   n[i, 1] = sum(counts[i - 1, 2:par[2]])
                   }
                   
                   # Get results.
                   n(counts)
                   
                   }

```

#####g. Model Runs
* Run your runs.

```{r age_struct_tma_run, eval = FALSE, include = FALSE}

# Run first test.
uh = fun_test(10, 27, ninit, v_mort, bymort, v_select_use, v_eggs, 50000, w)
vh = fun_test(10, 27, ninit, v_mort, bymort, v_select_use * 0, v_eggs, 50000, w)

wuh = sweep(uh, MARGIN = 2, w, '*')
wvh = sweep(vh, MARGIN = 2, w, '*')

```

#####h. Plots
* Plot your runs.

```{r age_struct_tma_ploots, eval = FALSE, include = FALSE}

# Using weights! Weights, not numbers!
# Reshape for a basic plot.
duh = data.frame(uh) %>% 
  mutate(t = seq(0, 9)) %>% 
  melt(id.vars = "t")

# Plot.
try_age =
ggplot(duh, aes(t, value, color = variable)) +
  geom_line()

# Reshape and fiddle for a presentable plot.
muh = data.frame(wuh) %>% 
  mutate(t = seq(2020, 2029)) %>% 
  melt(id.vars = "t") %>%
  group_by(t) %>% 
  summarise(s = sum(value)) %>% 
  mutate(s = s * 0.001) %>% 
  mutate(t = t - 3)

# Ditto, but for the counterfactual plot.
vuh = data.frame(wvh) %>% 
  mutate(t = seq(2020, 2029)) %>% 
  melt(id.vars = "t") %>%
  group_by(t) %>% 
  summarise(s = sum(value)) %>% 
  mutate(s = s * 0.001) %>% 
  mutate(t = t - 3)

# Theming chunk.
btheme =  theme(plot.title = element_text(hjust = 0.5, size = 32, family = "Century Gothic", face = "bold"), 
          rect = element_rect(fill = "transparent"),
          plot.background = element_rect(fill = "transparent", color = NA),
          legend.position = "right",
          legend.background = element_rect(fill = "transparent"),
          legend.box.background = element_rect(fill = "transparent"),
          legend.key = element_rect(fill="transparent", colour=NA),
          legend.text = element_text(size = 16, family = "Century Gothic"),
          legend.title = element_text(size = 18, family = "Century Gothic"),
          panel.background = element_rect(fill = "transparent"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.text.x = element_text(size = 18, family = "Century Gothic"),
          axis.title.x = element_text(size = 24, family = "Century Gothic", face = "bold"),
          axis.text.y = element_text(size = 18, family = "Century Gothic"),
          axis.title.y = element_text(size = 24, family = "Century Gothic", face = "bold"))

# Presentable plot.
try_sum = 
ggplot(muh, aes(t, s * 0.001)) +
  geom_segment(aes(x = -Inf, xend = Inf, y = 20, yend = 20), linetype = "dashed") +
  geom_segment(aes(x = -Inf, xend = Inf, y = 12.5, yend = 12.5), linetype = "dashed") +
  annotate("text", x = 2019.1, y = 21, label = "Target Biomass", size = 8, family = "Century Gothic") +
  annotate("text", x = 2020, y = 13.5, label = "Minimum Viable Biomass", size = 8, family = "Century Gothic") +
  geom_line(size = 3, color = "#1F4E79") +
  scale_x_continuous(expand = c(0, 0.225), limits = c(2017, 2026), breaks = c(2017, 2026)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 40)) +
  #ggtitle("Stock Forecast, 2017 - 2027") +
  labs(x = "Years", y = "Thousands of Tonnes of Biomass") +
  theme_classic() +
  btheme

# Save.
ggsave("fishy.png", 
       width = 720, 
       height = 490,
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

huh = left_join(muh, vuh, by = "t")

huh$s.y[1:5] = huh$s.x[1:4]

try_hum = 
ggplot(huh) +
  geom_segment(aes(x = -Inf, xend = 2026, y = 20, yend = 20), linetype = "dashed") +
  geom_segment(aes(x = -Inf, xend = 2026, y = 12.5, yend = 12.5), linetype = "dashed") +
  geom_ribbon(aes(t, ymin = s.x * 0.001, ymax = s.y * 0.001), fill = "#F4B183", alpha = 0.50) +
  geom_line(aes(t, s.y * 0.001), color = "#F4B183", size = 3) +
  geom_line(aes(t, s.x * 0.001), color = "#1F4E79", size = 3) +
  annotate("text", x = 2019.1, y = 21, label = "Target Biomass", size = 8, family = "Century Gothic") +
  annotate("text", x = 2020, y = 13.5, label = "Minimum Viable Biomass", size = 8, family = "Century Gothic") +
  scale_x_continuous(expand = c(0, 0.225), limits = c(2017, 2026), breaks = c(2017, 2026)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 40)) +
  #ggtitle("Stock Forecast, 2017 - 2027") +
  labs(x = "Years", y = "Thousands of Tonnes of Biomass") +
  theme_classic() +
  btheme

ggsave("fishier.png", 
       width = 720, 
       height = 490,
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

```

```{r otherploots, eval = FALSE, include = FALSE}
melt$variable = str_remove(melt$variable, "X")
melt$variable = as.numeric(melt$variable)

try3 = 
ggplot(melt, aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 1 - 30") +
  theme_void() + 
  theme(legend.position = "none") +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "RdBu")

tryfirst = 
ggplot(filter(melt, variable == 1), aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 1 - 30") +
  theme_void() + 
  theme(legend.position = "none") +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "RdBu")

trysecond = 
ggplot(filter(melt, variable < 11 & variable > 1), aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 2 - 10") +
  theme_void() + 
  theme(legend.position = "none",
        plot.title = element_text(size = 8)) +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "Purples")

trythird = 
ggplot(filter(melt, variable < 21 & variable > 10), aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 11 - 20") +
  theme_void() + 
  theme(legend.position = "none",
        plot.title = element_text(size = 8)) +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "Reds")

tryfourth = 
ggplot(filter(melt, variable < 31 & variable > 20), aes(x = variable, z = value, y = t, color = variable)) +
  ggtitle("Numbers at Age for 25 Years, Ages 21 - 30") +
  theme_void() + 
  theme(legend.position = "none",
        plot.title = element_text(size = 8)) +
  #axes_3D() + 
  stat_3D(geom = "point", phi = 45, theta = 135) +
  scale_color_distiller(palette = "Oranges")

ggsave("f1plot.png", plot = trysecond, dpi = 300, width = 3.25, height = 4.5)
ggsave("f2plot.png", plot = trythird, dpi = 300, width = 3.25, height = 4.5)
ggsave("f3plot.png", plot = tryfourth, dpi = 300, width = 3.25, height = 4.5)

```

