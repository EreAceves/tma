---
title: "Aquaculture Model - Demo"
date: '`r Sys.Date()`'
output: html_document
---

```{r pkg_ins, include = FALSE}

rm(list=ls())

# Check out knitr for knitr::read_chunk.
library(knitr)

# Name packages.
pkg <- c("readr",
         "knitr",
         "tidyverse",
         "gapminder",
         "sandwich",
         "cowplot",
         "reshape2",
         "broom",
         "kableExtra")

# Install packages.
#install.packages(pkg, verbose = FALSE, quiet = TRUE)

  
# Update packages.
#update.packages(pkg, verbose = FALSE, quiet = TRUE)

# Check out packages.
lapply(pkg, library, character.only = TRUE)

```

#####Objective: Step through optimal rotations for a generic totoaba farm.

#####Age to Length

$L(t) = L_\infty ( 1 - e^{ - K ( t - t_0 )})$

Variable   | Definition                   | Value
---------- | ---------------------------  | --------------
*L*        | Length (Centimeters)         | 
$L_\infty$ | Maximum Length (Centimeters) | 180.000000
*K*        | Catabolic Constant (?!)      | 000.289291
*t*        | Age (Years)                  | 
$t_0$      | Age, *L* = 0                 | 000.000000

```{r al_function}

# Von Bertalanffy function.
fn_vb = function(linf, k, t, t_0){l = linf * ( 1 - exp( - k * ( t - t_0)))
                                  return(l)}

# Set parameter values for future reference.
vb_linf = 180
vb_k    = 0.289291
vb_t0   = 0.015

# Parameterization demo.
a = seq(1, 20)
l = fn_vb(vb_linf, vb_k, a, vb_t0)
plot(a, l)

# Better graph for Goto.
ggvb =
ggplot() +
  geom_path(aes(a, l), colour = "firebrick") +
    labs(x = "Age (Years)", y = "Length (Centimeters)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Length-at-Age Function") +
  theme(axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        legend.title = element_text(size = 9),
        plot.title = element_text(size = 9)) +
  theme_classic()

#ggsave("ggvb.png", ggvb, width = 5.5, height = 3, dpi = 300)

```

#####Age to Mortality

Cygnus Ocean Farms, SA de CV report mortality by month for two years.
 
```{r am_data}

a_months = seq(1, 24)
m_months = c(rep(5.00, 2), rep(2.40, 2), rep(1.60, 2), rep(1.15, 2), rep(1.00, 3), rep(0.80, 3), 0.50, rep(0.40, 6), 0.30, rep(0.20, 2))

dat_m = tibble(a_months, m_months)

#plot(dat_m$a_months, dat_m$m_months)

```
 
Supposing a mortality trend $m = \beta_1 * e^{\beta_2a}$, R function nls in package Stats 3.4.2 returns:
 
```{r am_results, echo = FALSE}

# Specification for nonlinear regression:
am_reg = nls(m_months ~ b1 * exp(b2 * a_months), dat_m, start = list(b1 = 8.00, b2 = - 1.00))

# Clean up output:
am_reg_tidy = tidy(am_reg, conf.int = TRUE, conf.level = 0.95)
dat_m_est = augment(am_reg)

kable(am_reg_tidy)

ggplot(dat_m_est) +
  geom_point(aes(a_months, m_months)) +
  geom_path(aes(a_months, .fitted))

# Better graph for Goto.
ggam =
ggplot(dat_m_est) +
  geom_point(aes(a_months, m_months), colour = "gray50") +
  geom_segment(aes(x = a_months, y = m_months, xend = a_months, yend = .fitted), colour = "gray50") +
  geom_point(aes(a_months, .fitted), colour = "firebrick") +
  labs(x = "Age (Months)", y = "Cohort Mortality (%)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Mortality-at-Age Function") +
  theme(axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        legend.title = element_text(size = 9),
        plot.title = element_text(size = 9)) +
  theme_classic()

#ggsave("ggam.png", ggam, width = 5.5, height = 3, dpi = 300)

```

 Those results plug into a mortality-at-age function:


Variable   | Definition                  | Value
---------- | --------------------------- | -----------
*m*        | Cohort Mortality (%)        |
*a*        | Age (Months)                |
$\beta_1$  | Parameter                   | `r am_reg_tidy$estimate[1]`
$\beta_2$  | Parameter                   | `r am_reg_tidy$estimate[2]`

~~To keep a realistic non-zero mortality-at-age estimate, we add a proportional mortality of 0.01 to each month of age.~~

For convenience below, the indefinite integral of mortality-at-age, i.e. cumulative mortality, is also defined as:
$M = \frac{\beta_1 * e^{\beta_2a}}{\beta_2}$

```{r am_function}

# Set marginal mortality.
fn_am_marg = function(a, b1, b2){m = b1 * exp(b2 * a)} 

# Set cumulative mortality.
fn_am_cumu = function(a, b1, b2){M = (b1 * exp(b2 * a)) / b2}

# Set parameters for reference.
am_b1 = am_reg_tidy$estimate[1]
am_b2 = am_reg_tidy$estimate[2]

```

#####Weight-Length Conversion

$W = aL^b$

Variable   | Definition
---------- | ---------------------------
*W*        | Weight (Kilograms)
*L*        | Length (Centimeters)
*a*        | Parameter
*b*        | Parameter

```{r lw_function}

# Generic length-to-weight conversion. 
fn_lw = function(a, l, b){w = a * l ^ b
                          return(w)}

# Set parameter values for future reference.
wl_a = 0.000004128
wl_b = 3.24674

# Parameterization demo.
l = seq(0, 180, by = 10)
w = fn_lw(wl_a, l, wl_b)
plot(l, w)

# Better graph for Goto.
gglw =
ggplot() +
  geom_path(aes(l, w), colour = "firebrick") +
    labs(x = "Length (Centimeters)", y = "Weight (Kilograms)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Weight-at-Length Function") +
  theme(axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        legend.title = element_text(size = 9),
        plot.title = element_text(size = 9)) +
  theme_classic()

#ggsave("gglw.png", gglw, width = 5.5, height = 3, dpi = 300)

```

#####Age to Count

After mortality, any biomass in excess of optimal stocking density is harvested. Optimal density is 140,000 kilograms per cage at and after first salable size.

First salable size is set to 2 kilograms.

$T = n_t^* - n_{t-1}^* * m_{t-1}$

```{r ac_calc}

# Density is highest possible kilograms per cubic meter without density-dependence slowing growth.
density = 160000

# Size is first saleable size in kilograms.
size = 2

am = seq(1, 240)
ay = seq(1/12, 20, by = 1/12)
amlag = am - 1
w = fn_lw(wl_a, fn_vb(vb_linf, vb_k, ay, vb_t0), wl_b)
n = density / w * (1 - 0.01 * fn_am_marg(amlag, am_b1, am_b2))

# Hard-coding mortality yields a unidimensional function for integration below.

# Cohort count at first saleable size is the ratio of density in kgm^-3 to size in kg.
nsale = density / size

# Initial cohort count is cohort count at first saleable size, plus cumulative mortality at first saleable age.
# Casually, nstart = nsale + mort(a(l(wsale)))
# Cumulative mortality to first saleable age:
a_sale = (vb_t0 - 1 / vb_k * (log(1 - ((size / wl_a) ^ (1 / wl_b))/vb_linf))) * 12
m_sale = integrate(fn_am_marg, lower = 0, upper = a_sale, b1 = am_b1, b2 = am_b2)

# Initial cohort count:
nstart = nsale + nsale * ((m_sale$value) * 0.01)

# Trimming experiment:


```

#####Weight-Maw Conversion

For a stock of $n_{a, t}$ totoaba cultivated for *a* years in year *t* to weight $w_{a, t}$ for a total round weight of $x_{a, t}$, maw yield $y_{a, t}$ depends on wet maw yield ratio $c^{maw}_{a, t}$ and dry yield ratio $k$.

$y^{maw}_{a, t} = w_{a, t}n_{a, t}c^{maw}_{a, t}k^{maw}_{dry}$

Variable   | Definition
---------- | --------------------------------
$y^{maw}$  | Cohort Dry Maw Yield (Kilograms)
*w*        | Individual Round Weight (Kilograms)
*n*        | Cohort Count
$c^{maw}$  | Yield of maw from round weight.
$k^{maw}$  | Yield of dry maw from wet maw.

```{r wm_function}

fn_wm = function(w, n, c, k){ymaw = w * n * c * k}

# Parameters from literature:
wm_c = 0.02
wm_k = 0.40

```

#####Maw-Price Conversion

Plug the market model in here.

```{r mp_function}

#fn_mp = function(w, b0, bw, bq, q, bc, c){pmaw = b0 + w ^ bw + bq * q + bc * c}
fn_mp = function(w, b0, b1){pmaw = b0 + w^b1}

# Parameters from regression.
mp_b0 = 25
mp_b1 = 1.75

```

#####Maw-Revenue Conversion

Fix from regression specification. See Maw-Price Conversion.

For a dry maw yield $y^{maw}$ in kilograms, revenue depends on price.

$R^{maw}_{a, t} = x_{a, t}/n_{a, t} * (\beta_0 + \beta_{g}(x_{a, t}/n_{a, t}))$

```{r mr_function}

fn_mr = function(ymaw, pmaw){rmaw = ymaw * pmaw}

```

#####Round-Revenue Conversion

For a stock of *n* totoaba cultivated for *a* years in year *t* for an individual round weight of $w_{a, t}$, revenue depends on price.

$R^{round}_{a, t} = w_{a, t} * n_{a, t} * p^{round}$

```{r wr_function}

fn_fr = function(w, n, pround){rround = w * n * pround}

# Parameter from market research:
pround = 6.50

```

#####Feed Conversion Function

Thanks, Goto!

```{r fcr_data}

dat_fcr = read.csv("fcr.csv")

# Convert values from grams to kilograms for later.
dat_fcr$weight = dat_fcr$weight / 1000
dat_fcr$feed = dat_fcr$feed / 1000

```

For reasons, we assume functional form $F = \beta_1 * w^{\beta_2}$

```{r fcr_results}

# Specification for nonlinear regression:
fcr_reg = nls(feed ~ b1 * weight ^ b2, dat_fcr, start = list(b1 = 0.0268, b2 = - 1.855))

# Clean up output:
fcr_reg_tidy = tidy(fcr_reg, conf.int = TRUE, conf.level = 0.95)
dat_fcr_est = augment(fcr_reg)

kable(fcr_reg_tidy)

ggplot(dat_fcr_est) +
  geom_point(aes(weight, feed)) +
  geom_point(aes(weight, .fitted, colour = "red"))

# Better graph for Goto.
ggfcr =
ggplot(dat_fcr_est) +
  geom_point(aes(weight, feed), colour = "gray50") +
  geom_segment(aes(x = weight, y = feed, xend = weight, yend = .fitted), colour = "gray50") +
  geom_point(aes(weight, .fitted), colour = "firebrick") +
  labs(x = "Weight (Kilograms)", y = "Feed Requirement (Kilograms)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Feed-at-Weight Function") +
  theme(axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        legend.title = element_text(size = 9),
        plot.title = element_text(size = 9)) +
  theme_classic()

#ggsave("ggfcr.png", ggfcr, width = 5.5, height = 3, dpi = 300)

```

Those results plug into a feed-at-weight function:

Variable   | Definition                  | Value
---------- | --------------------------- | -----------
*w*        | Weight (Kilograms)          |
*f*        | Cumulative Feed (Kilograms) |
$\beta_1$  | Parameter                   | `r fcr_reg_tidy$estimate[1]`
$\beta_2$  | Parameter                   | `r fcr_reg_tidy$estimate[2]`

For convenience below, the derivative of feed-at-weight, i.e. instantaneous feed requirement, is also defined as:
$f = \beta_1 \beta_2 w^{\beta_{1}-1}$

```{r fcr_function}

# Set cumulative feed requirement.
fn_f_cumu = function(w, b1, b2){F = b1 * w ^ b2}

# Set marginal feed requirement.
fn_f_marg = function(w, b1, b2){f = b1 * b2 * w ^ (b2 - 1)} 

# Set parameters for reference.
f_b1 = fcr_reg_tidy$estimate[1]
f_b2 = fcr_reg_tidy$estimate[2]

```

#####No-Harvest Cost

Thanks, Goto!

```{r c_stock}

# Marginal cohort cost.
fn_ch0 = function(w, b1, b2, cf, n, o){ch0 = n * cf * fn_f_marg(w, b1, b2) + o}

# Parameters.
#  Cost, USD/kg.
ch0_cf = 1.545
# Overhead, from eight cages for ten years down to one cage for one year.
o = 87500

# Demo.
w = seq(0, 200)
n = seq(4200, 4000)

ch0_demo = fn_ch0(w, f_b1, f_b2, ch0_cf, n, o)

plot(w, ch0_demo)

```


#####Harvest Cost

```{r c_restock}

ch1 = nstart * 2 + o

```


#####No-Harvest Demo

Without a harvest mechanism, this series of functions and vectors just demonstrates revenue and cost curves driving harvest in the next step.

```{r demo_noharvest}

t = seq(1, 25)
l = fn_vb(vb_linf, vb_k, t, vb_t0)
w = fn_lw(wl_a, l, wl_b)
#n = nstart - nstart * (100 + fn_am_cumu(t * 12, am_b1, am_b2)) * 0.01
ymaw = fn_wm(w, 1500, wm_c, wm_k)
pmaw = fn_mp(w, mp_b0, mp_b1)
rmaw = fn_mr(ymaw, pmaw)
rround = fn_fr(w, 1500, pround)
r = rround + rmaw 
c =  fn_ch0(w, f_b1, f_b2, ch0_cf, 1500, o)# + 25 * w ^ 2.5 # Note suffix for corrective shift up. Fix it.

demo_h0 = data.frame(t, r, c)

demo_h0 = melt(demo_h0, id = 1)

noh = ggplot(demo_h0, aes(t, value, colour = variable)) +
              geom_path()

# Save no-harvest plot to working directory.
#ggsave("nohplot.png", plot = noh, dpi = 300, width = 6.5, height = 4.5)

# Save no-harvest table to working directory.
#kable(demo_h0, digits = 2) %>%
#  kable_styling() %>%
#  save_kable(file = "nohtab.html", self_contained = T)

```


#####Single Run, Harvest Demo

```{r demo_harvest}

# Define parameters for each low-level function in a high-level function of multiple harvests over time
var = c("start", 
        "end", 
        "linf", 
        "k",
        "t0", 
        "a", 
        "b", 
        "n0", 
        "yround", 
        "ywet", 
        "b0", 
        "b1",
        "pround", 
        #"c_coeff",
        #"c_exp",
        "f_b1", 
        "f_b2", 
        "ch0_cf", 
        "o",
        "c_restock",
        "disc")


par = c(1, 
        25, 
        vb_linf, 
        vb_k, 
        vb_t0,
        wl_a,
        wl_b,
        1500,
        wm_c,
        wm_k,
        mp_b0,
        mp_b1,
        pround,
        #10000,
        #2.00,
        f_b1, 
        f_b2, 
        ch0_cf, 
        o,
        ch1,
        0.95)

fun = c(rep("All", 2), 
        rep("Age-Length", 3),
        rep("Length-Weight", 2),
        rep("Weight-Maw", 3),
        rep("Maw-Price", 2),
        "Weight-Revenue (Round)",
        rep("No-Harvest Cost", 4),
        "Harvest Cost",
        "Discount Factor")

num = seq(1, length(var))

tab = data.frame(num, fun, var, par)

# Save parameters to working directory.
#kable(tab, digits = 2) %>%
#  kable_styling() %>%
#  save_kable(file = "partab.html", self_contained = T)


# Define a function for dynamic harvests over time.
aq = function(par){t = as.numeric(vector(length = par[2]))
                   a0 = as.numeric(vector(length = par[2]))
                   a1 = as.numeric(vector(length = par[2]))

                   h = as.numeric(vector(length = par[2]))
                   hinv = as.numeric(vector(length = par[2]))
                   
                   l0 = as.numeric(vector(length = par[2]))
                   w0 = as.numeric(vector(length = par[2]))
                   n0 = as.numeric(vector(length = par[2]))
                   y0 = as.numeric(vector(length = par[2]))
                   n0 = as.numeric(vector(length = par[2]))
                   p0 = as.numeric(vector(length = par[2]))
                   rmaw0 = as.numeric(vector(length = par[2]))
                   rround0 = as.numeric(vector(length = par[2]))
                   r0 = as.numeric(vector(length = par[2]))
                   c0 = as.numeric(vector(length = par[2]))
                   
                   l1 = as.numeric(vector(length = par[2]))
                   w1 = as.numeric(vector(length = par[2]))
                   n1 = as.numeric(vector(length = par[2]))
                   y1 = as.numeric(vector(length = par[2]))
                   n1 = as.numeric(vector(length = par[2]))
                   p1 = as.numeric(vector(length = par[2]))
                   rmaw1 = as.numeric(vector(length = par[2]))
                   rround1 = as.numeric(vector(length = par[2]))
                   r1 = as.numeric(vector(length = par[2]))
                   c1 = as.numeric(vector(length = par[2]))
                   
                   r = as.numeric(vector(length = par[2]))
                   c = as.numeric(vector(length = par[2]))
                  
                   t[1] = par[1]
                   a0[1] = t[1]
                   a1[1] = a0[1] + 1
                   
                   h[1] = 0
                   hinv[1] = 1
                   
                   l0[1] = fn_vb(par[3], par[4], t[1], par[5])
                   w0[1] = fn_lw(par[6], l0[1], par[7])
                   n0[1] = par[8]
                   y0[1] = fn_wm(w0[1], n0[1], par[9], par[10])
                   p0[1] = fn_mp(w0[1], par[11], par[12])
                   rmaw0[1] = y0[1] * p0[1]
                   rround0[1] = w0[1] * par[13]
                   r0[1] = (rmaw0[1] + rround0[1]) # * h[1]
                   c0[1] = fn_ch0(w0[1], par[14], par[15], par[16], par[8], par[17])

                   l1[1] = fn_vb(par[3], par[4], 2, par[5])
                   w1[1] = fn_lw(par[6], l1[1], par[7])
                   n1[1] = par[8]
                   y1[1] = fn_wm(w1[1], n1[1], par[9], par[10])
                   p1[1] = fn_mp(w1[1], par[11], par[12])
                   rmaw1[1] = y1[1] * p1[1]
                   rround1[1] = w1[1] * par[13]
                   r1[1] = (rmaw1[1] + rround1[1]) # * h[1]
                   c1[1] = fn_ch0(w1[1], par[14], par[15], par[16], par[8], par[17])
                   
                   r[1] = r0[1]
                   c[1] = c0[1]
                                     
                   for(i in 2:par[2]){
                     t[i] = t[i - 1] + 1
                     
                     a0[i] = a0[i - 1] * hinv[i - 1] + 1
                     a1[i] = a0[i] + 1
                     
                     l0[i] = fn_vb(par[3], par[4], a0[i], par[5])
                     w0[i] = fn_lw(par[6], l0[i], par[7])
                     n0[i] = par[8]
                     y0[i] = fn_wm(w0[i], n0[i], par[9], par[10])
                     p0[i] = fn_mp(w0[i], par[11], par[12])
                     rmaw0[i] = y0[i] * p0[i]                         # Fix yield-revenue function for maw.
                     rround0[i] = fn_fr(w0[i], n0[i], par[13])
                     r0[i] = rmaw0[i] + rround0[i]
                     c0[i] = fn_ch0(w0[i], par[14], par[15], par[16], n0[i], par[17])
                     
                     l1[i] = fn_vb(par[3], par[4], a1[i], par[5])
                     w1[i] = fn_lw(par[6], l1[i], par[7])
                     n1[i] = par[8]
                     y1[i] = fn_wm(w1[i], n1[i], par[9], par[10])
                     p1[i] = fn_mp(w1[i], par[11], par[12])
                     rmaw1[i] = y1[i] * p1[i]                         # Fix yield-revenue function for maw.
                     rround1[i] = fn_fr(w1[i], n1[i], par[13])
                     r1[i] = rmaw1[i] + rround1[i]
                     c1[i] = fn_ch0(w1[i], par[14], par[15], par[16], n1[i], par[17])
                     
                     # Mind wrapper for hard-coding lower bound age at harvest.
                     h[i] = ifelse(a0[i] > 6, ifelse((r0[i] - c0[i]) > (par[19] * (r1[i] - c1[i])), 1, 0), 0)
                     hinv[i] = (h[i] - 1) ^ 2
                     
                     r[i] = r0[i]
                     c[i] = c0[i] 
                     
                     }
                    
                    output = tibble(t, c, r, h)

                  return(output)}

# Run the dynamic harvest demo from parameters.
output = aq(par)

tibble_rc = melt(output, id = 1)

colnames(tibble_rc) = c("t", "var", "val")

# Plot cumulative revenues and costs through harvest cycles.
h = ggplot(tibble_rc, aes(t, val, colour = var)) +
            geom_point(aes(fill = var), alpha = 0.5)

# Save harvest plot to working directory.
#ggsave("hplot.png", plot = h, dpi = 300, width = 6.5, height = 4.5)

# Save output to working directory.
#kable(output) %>%
#  kable_styling() %>%
#  save_kable(file = "htab.html", self_contained = T)

# Calculate and plot profit.
tbl_pi = output %>% 
  mutate(., c1 = lead(c)) %>% 
  mutate(., mc = ifelse(c1 - c > 0, c1 - c, 0)) %>% 
  mutate(., rsale = r * h) %>% 
  mutate(., pi = rsale - mc)

plot(tbl_pi$t, tbl_pi$pi)

# Calculate and plot cumulative profit.
pi_sum = as.numeric(vector(length = par[2]))
pi_sum[1] = 0

for(i in 2:par[2]){pi_sum[i] = tbl_pi$r[i] * tbl_pi$h[i] - tbl_pi$mc[i] + pi_sum[i - 1]}

tbl_pi = cbind(tbl_pi, pi_sum)

# Add a column for color by vertical position.
tbl_pi = mutate(tbl_pi, color = ifelse(pi_sum > 0, 1, 0))

# Basic plot.  
plot(tbl_pi$t, tbl_pi$pi_sum)

# Better plot.
#ggplot(tbl_pi, aes(t, pi_sum)) +
#  geom_point()

```

