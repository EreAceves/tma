---
title: "Aquaculture Model - Demo"
output:
  pdf_document: default
  html_document: default
date: '`r Sys.Date()`'
---

```{r pkg_ins, include = FALSE}

rm(list=ls())

# Check out knitr for knitr::read_chunk.
library(knitr)

# Name packages.
pkg <- c("readr",
         "knitr",
         "tidyverse",
         "gapminder",
         "sandwich",
         "broom",
         "stargazer",
         "cowplot",
         "reshape2",
         "kableExtra")

# Install packages.
#install.packages(pkg, verbose = FALSE, quiet = TRUE)

  
# Update packages.
#update.packages(pkg, verbose = FALSE, quiet = TRUE)

# Check out packages.
lapply(pkg, library, character.only = TRUE)

```

#####Objective: Step through optimal rotations for a generic totoaba farm.

#####Age to Length

$L(t) = L_\infty ( 1 - e^{ - K ( t - t_0 )})$

Variable   | Definition                   | Value
---------- | ---------------------------  | --------------
*L*        | Length (Centimeters)         | 
$L_\infty$ | Maximum Length (Centimeters) | 180.000000
*K*        | Catabolic Constant (?!)      | 000.289291
*t*        | Age (Years)                  | 
$t_0$      | Age, *L* = 0                 | 000.000000

```{r al_function}

# Von Bertalanffy function.
fn_vb = function(linf, k, t, t_0){l = linf * ( 1 - exp( - k * ( t - t_0)))
                                  return(l)}

# Set parameter values for future reference.
vb_linf = 180
vb_k    = 0.289291
vb_t0   = 0

# Parameterization demo.
a = seq(1, 20)
l = fn_vb(vb_linf, vb_k, a, vb_t0)
plot(a, l)

```

#####Age to Mortality

Cygnus Ocean Farms, SA de CV report mortality by month for two years.
 
```{r am_data}

a_months = seq(1, 24)
m_months = c(rep(5.00, 2), rep(2.40, 2), rep(1.60, 2), rep(1.15, 2), rep(1.00, 3), rep(0.80, 3), 0.50, rep(0.40, 6), 0.30, rep(0.20, 2))

dat_m = tibble(a_months, m_months)

#plot(dat_m$a_months, dat_m$m_months)

```
 
 Supposing a mortality trend $m = \beta_1 * e^{\beta_2a}$, R function nls in package Stats 3.4.2 returns:
 
```{r am_results, echo = FALSE}

# Specification for nonlinear regression:
am_reg = nls(m_months ~ b1 * exp(b2 * a_months), dat_m, start = list(b1 = 8.00, b2 = - 1.00))

# Clean up output:
am_reg_tidy = tidy(am_reg, conf.int = TRUE, conf.level = 0.95)
dat_m_est = augment(am_reg)

kable(am_reg_tidy)

ggplot(dat_m_est) +
  geom_point(aes(a_months, m_months)) +
  geom_path(aes(a_months, .fitted))

```

 Those results plug into a mortality-at-age function:


Variable   | Definition                  | Value
---------- | --------------------------- | -----------
*m*        | Cohort Mortality (%)        |
*a*        | Age (Months)                |
$\beta_1$  | Parameter                   | `r am_reg_tidy$estimate[1]`
$\beta_2$  | Parameter                   | `r am_reg_tidy$estimate[2]`
 
```{r am_function}

# Set function.
fn_am = function(b1, b2, a){m = b1 * exp(b2 * a_months)}

# Set parameters for reference.
am_b1 = am_reg_tidy$estimate[1]
am_b2 = am_reg_tidy$estimate[2]

```

#####Weight-Length Conversion

$W = aL^b$

Variable   | Definition
---------- | ---------------------------
*W*        | Weight (Kilograms)
*L*        | Length (Centimeters)
*a*        | Parameter
*b*        | Parameter

```{r lw_function}

# Generic length-to-weight conversion. 
fn_lw = function(a, l, b){w = a * l ^ b
                          return(w)}

# Set parameter values for future reference.
wl_a = 0.000004128
wl_b = 3.24674

# Parameterization demo.
l = seq(1, 180, by = 10)
w = fn_lw(wl_a, l, wl_b)
plot(l, w)

```

#####Age to Count

After mortality, any biomass in excess of optimal stocking density is harvested. Optimal density is 140,000 kilograms per cage at and after first salable size.

First salable size is set to 143 grams for a rough plate size.

$T = n_t^* - n_{t-1}^* * m_{t-1}$

```{r ac_calc}

density = 140000
size = 0.143

a = seq(1, 20)
alag = a - 1
w = fn_lw(wl_a, fn_vb(vb_linf, vb_k, a, vb_t0), wl_b)
n = density / w * fn_am(am_b1, am_b2, alag)


```




Weight to Round Revenue
 - Data
 - Methods
 - Results

Weight to Maw Revenue
 - Data
 - Methods
 - Results

Weight to Feed Cost
 - Data
 - Methods
 - Results

Constant Cost
 - Data
 - Methods
 - Results

Stocking Cost
 - Data
 - Methods
 - Results

Discounting
 - Data
 - Methods
 - Results

#####Weight-Maw Conversion

For a stock of $n_{a, t}$ totoaba cultivated for *a* years in year *t* to weight $w_{a, t}$ for a total round weight of $x_{a, t}$, maw yield $y_{a, t}$ depends on wet maw yield ratio $c^{maw}_{a, t}$ and dry yield ratio $k$.

$y^{maw}_{a, t} = w_{a, t}n_{a, t}c^{maw}_{a, t}k^{maw}_{dry}$

Variable   | Definition
---------- | --------------------------------
$y^{maw}$  | Cohort Dry Maw Yield (Kilograms)
*w*        | Individual Round Weight (Kilograms)
*n*        | Cohort Count
$c^{maw}$  | Yield of maw from round weight.
$k^{maw}$  | Yield of dry maw from wet maw.

```{r wm_function}

fn_wm = function(w, n, c, k){ymaw = w * n * c * k
                             return(ymaw)}

```

#####Maw-Price Conversion

Plug the market model in here.

```{r mp_function}

#fn_mp = function(w, b0, bw, bq, q, bc, c){pmaw = b0 + w ^ bw + bq * q + bc * c}
fn_mp = function(w, b0, b){pmaw = b0 + w^b
                           return(pmaw)}

```

#####Maw-Revenue Conversion

Fix from regression specification. See Maw-Price Conversion.

For a dry maw yield $y^{maw}$ in kilograms, revenue depends on price.

$R^{maw}_{a, t} = x_{a, t}/n_{a, t} * (\beta_0 + \beta_{g}(x_{a, t}/n_{a, t}))$

```{r mr_function}

fn_mr = function(ymaw, pmaw){rmaw = ymaw * pmaw
                             return(rmaw)}

```

#####Round-Revenue Conversion

For a stock of *n* totoaba cultivated for *a* years in year *t* for an individual round weight of $w_{a, t}$, revenue depends on price.

$R^{round}_{a, t} = w_{a, t} * n_{a, t} * p^{round}$

```{r wr_function}

fn_fr = function(w, n, pround){rround = w * n * pround
                               return(rround)}

```

#####Feed Conversion Function

Check in with Goto. Fix.

```{r fcr_function}

#fn_fcr = function(w, fcr){}

```


#####No-Harvest Cost

Fix FCR, then fix this.

```{r c_stock}

# Feed costs for a cohort.

fn_ch0 = function(t, cstock, n){ch0 = (10000000 * t ^ cstock + 100000000) * n
                                return(ch0)}#{cstock = ccoeff * a ^ cexp - cintercept}

```


#####Harvest Cost

Cost of restocking a cage after harvest. USD?

```{r c_restock}

# Cost of fry plus overhead.

#fn_ch1 = function(){}

```


#####No-Harvest Demo

Without a harvest mechanism, this series of functions and vectors just demonstrates revenue and cost curves driving harvest in the next step.

```{r demo_noharvest}

t = seq(0, 25)
m = fn_am(am_b1, am_b2, t)
l = fn_vb(1465.3822, 0.1280, t, -0.2805)
w = fn_lw(0.000015491, l, 2.92167)
ymaw = fn_wm(w, 1, 0.40, 0.02)
pmaw = fn_mp(w, 25, 1.75)
rmaw = fn_mr(ymaw, pmaw)
rround = fn_fr(w, 1, 50000)
r = rround + rmaw + 500000000
c =  10000000 * t ^ 2.15

demo_h0 = data.frame(t, r, c)

demo_h0 = melt(demo_h0, id = 1)

ggplot(demo_h0, aes(t, value, colour = variable)) +
  geom_path()


```


#####Single Run, Harvest Demo

```{r demo_harvest}

# Define parameters for each low-level function in a high-level function of multiple harvests over time
var = c("start", 
        "end", 
        "linf", 
        "k",
        "t0", 
        "a", 
        "b", 
        "n0", 
        "yround", 
        "ywet", 
        "b0", 
        "b1",
        "pround", 
        #"c_coeff",
        #"c_exp",
        "c_stock",
        "c_restock",
        "disc")


par = c(1, 
        50, 
        1465, 
        0.1280, 
        -0.2805,
        0.000015491,
        2.92167,
        1,
        0.4,
        0.02,
        25,
        1.75,
        5000,
        #10000,
        #2.00,
        2.15,
        2000,
        0.95)

fun = c(rep("All", 2), 
        rep("Age-Length", 3),
        rep("Length-Weight", 2),
        rep("Weight-Maw", 3),
        rep("Maw-Price", 2),
        "Weight-Revenue (Round)",
        #rep("No-Harvest Cost", 2), 
        "No-Harvest Cost",
        "Harvest Cost",
        "Discount Factor")

num = seq(1, length(var))

tab = data.frame(num, fun, var, par)

kable(tab)

# Define a function for dynamic harvests over time.
aq = function(par){t = as.numeric(vector(length = par[2]))
                   a0 = as.numeric(vector(length = par[2]))
                   a1 = as.numeric(vector(length = par[2]))

                   h = as.numeric(vector(length = par[2]))
                   hinv = as.numeric(vector(length = par[2]))
                   
                   l0 = as.numeric(vector(length = par[2]))
                   w0 = as.numeric(vector(length = par[2]))
                   n0 = as.numeric(vector(length = par[2]))
                   y0 = as.numeric(vector(length = par[2]))
                   n0 = as.numeric(vector(length = par[2]))
                   p0 = as.numeric(vector(length = par[2]))
                   rmaw0 = as.numeric(vector(length = par[2]))
                   rround0 = as.numeric(vector(length = par[2]))
                   r0 = as.numeric(vector(length = par[2]))
                   c0 = as.numeric(vector(length = par[2]))
                   
                   l1 = as.numeric(vector(length = par[2]))
                   w1 = as.numeric(vector(length = par[2]))
                   n1 = as.numeric(vector(length = par[2]))
                   y1 = as.numeric(vector(length = par[2]))
                   n1 = as.numeric(vector(length = par[2]))
                   p1 = as.numeric(vector(length = par[2]))
                   rmaw1 = as.numeric(vector(length = par[2]))
                   rround1 = as.numeric(vector(length = par[2]))
                   r1 = as.numeric(vector(length = par[2]))
                   c1 = as.numeric(vector(length = par[2]))
                   
                   r = as.numeric(vector(length = par[2]))
                   c = as.numeric(vector(length = par[2]))
                  
                   t[1] = par[1]
                   a0[1] = t[1]
                   a1[1] = a0[1] + 1
                   
                   h[1] = 0
                   hinv[1] = 1
                   
                   l0[1] = fn_vb(par[3], par[4], t[1], par[5])
                   w0[1] = fn_lw(par[6], l0[1], par[7])
                   n0[1] = par[8]
                   y0[1] = fn_wm(w0[1], n0[1], par[9], par[10])
                   p0[1] = fn_mp(w0[1], par[11], par[12])
                   rmaw0[1] = y0[1] * p0[1]
                   rround0[1] = w0[1] * par[13]
                   r0[1] = (rmaw0[1] + rround0[1]) # * h[1]
                   c0[1] = 0 #fn_ch0(w[1], par[14], n[1])

                   l1[1] = fn_vb(par[3], par[4], 2, par[5])
                   w1[1] = fn_lw(par[6], l1[1], par[7])
                   n1[1] = par[8]
                   y1[1] = fn_wm(w1[1], n1[1], par[9], par[10])
                   p1[1] = fn_mp(w1[1], par[11], par[12])
                   rmaw1[1] = y1[1] * p1[1]
                   rround1[1] = w1[1] * par[13]
                   r1[1] = (rmaw1[1] + rround1[1]) # * h[1]
                   c1[1] = 0 #fn_ch0(w[1], par[14], n[1])
                   
                   r[1] = r0[1]
                   c[1] = c0[1]
                                     
                   for(i in 2:par[2]){
                     t[i] = t[i - 1] + 1
                     
                     a0[i] = a0[i - 1] * hinv[i - 1] + 1
                     a1[i] = a0[i] + 1
                     
                     l0[i] = fn_vb(par[3], par[4], a0[i], par[5])
                     w0[i] = fn_lw(par[6], l0[i], par[7])
                     n0[i] = par[8]
                     y0[i] = fn_wm(w0[i], n0[i], par[9], par[10])
                     p0[i] = fn_mp(w0[i], par[11], par[12])
                     rmaw0[i] = y0[i] * p0[i]                         # Fix yield-revenue function for maw.
                     rround0[i] = fn_fr(w0[i], n0[i], par[13])
                     r0[i] = rmaw0[i] + rround0[i]
                     c0[i] = fn_ch0(a0[i], par[14], n0[i]) # * hinv[i] + par[15] * h[i]
                     
                     l1[i] = fn_vb(par[3], par[4], a1[i], par[5])
                     w1[i] = fn_lw(par[6], l1[i], par[7])
                     n1[i] = par[8]
                     y1[i] = fn_wm(w1[i], n1[i], par[9], par[10])
                     p1[i] = fn_mp(w1[i], par[11], par[12])
                     rmaw1[i] = y1[i] * p1[i]                         # Fix yield-revenue function for maw.
                     rround1[i] = fn_fr(w1[i], n1[i], par[13])
                     r1[i] = rmaw1[i] + rround1[i]
                     c1[i] = fn_ch0(a1[i], par[14], n1[i]) # * hinv[i] + par[15] * h[i]
                     
                     # Mind wrapper for hard-coding lower bound age at harvest.
                     h[i] = ifelse(a0[i] > 6, ifelse((r0[i] - c0[i]) > (par[16] * (r1[i] - c1[i])), 1, 0), 0)
                     hinv[i] = (h[i] - 1) ^ 2
                     
                     r[i] = r0[i]
                     c[i] = c0[i] 
                     
                     }
                    
                    output = tibble(t, h, r, c) #tibble(t, h, r, c)

                  return(output)}

# Run the dynamic harvest demo from parameters.
output = aq(par)

tibble_rc = melt(output, id = 1)

colnames(tibble_rc) = c("t", "var", "val")

# Plot cumulative revenues and costs through harvest cycles.
ggplot(tibble_rc, aes(t, val, colour = var)) +
  geom_area(aes(fill = var), alpha = 0.5)


# Calculate and plot profit.
tbl_pi = output %>% 
  mutate(., c1 = lead(c)) %>% 
  mutate(., mc = ifelse(c1 - c > 0, c1 - c, 0)) %>% 
  mutate(., rsale = r * h) %>% 
  mutate(., pi = rsale - mc)

plot(tbl_pi$t, tbl_pi$pi)

# Calculate and plot cumulative profit.
pi_sum = as.numeric(vector(length = par[2]))
pi_sum[1] = 0

for(i in 2:par[2]){pi_sum[i] = tbl_pi$r[i] * tbl_pi$h[i] - tbl_pi$mc[i] + pi_sum[i - 1]}

tbl_pi = cbind(tbl_pi, pi_sum)

# Add a column for color by vertical position.
tbl_pi =  mutate(tbl_pi, color = ifelse(pi_sum > 0, 1, 0))

# Basic plot.  
plot(tbl_pi$t, tbl_pi$pi_sum)

# Area plot.
ggplot(tbl_pi, aes(t, pi_sum)) +
  geom_area()

```

