---
title: "Aquaculture Model"
date: "`r Sys.Date()`"
output: html_document
---

```{r pkg_ins, include = FALSE}

#rm(list=ls())

# Check out knitr for knitr::read_chunk.
library(knitr)

# Name packages.
pkg <- c("readr",
         "knitr",
         "tidyverse",
         "gapminder",
         "sandwich",
         "broom",
         "stargazer",
         "cowplot",
         "reshape2",
         "kableExtra")

# Install packages.
#install.packages(pkg, verbose = FALSE, quiet = TRUE)

  
# Update packages.
#update.packages(pkg, verbose = FALSE, quiet = TRUE)

# Check out packages.
lapply(pkg, library, character.only = TRUE)

```

#####Objective: Step through optimal harvest and planting decisions by a generic totoaba farm..

Toy Model:

Parameters for White seabass (Cynoscion nobiliis) from:
Thomas, J. C. (1968). Management of the white seabass (Cynoscion nobilis) in California waters. State of California. The Resources Agency. Department of Fish and Game.

#####Von Bertalanffy Growth Model

$L(t) = L_\infty ( 1 - e^{ - K ( t - t_0 )})$

Variable   | Definition
---------- | ---------------------------
*L*        | Length (Millimeters)
$L_\infty$ | Maximum Length (mm)
*K*        | Catabolic Constant (?!)
*t*        | Age (Years)
$t_0$      | Age, *L* = 0

```{r al_function}

# Von Bertalanffy function.
fn_vb = function(linf, k, t, t_0){l = linf * ( 1 - exp( - k * ( t - t_0)))
                                  return(l)}

# White seabass demo with age in years and length in millimeters.
v_vb_a_wsb = seq(0, 25)
v_vb_l_wsb = fn_vb(1465.3822, 0.1280, v_vb_a_wsb, -0.2805)
plot(v_vb_a_wsb, v_vb_l_wsb)


# Totoaba demo.
#v_vb_a_tma = seq(a0, amax)
#v_vb_l_tma = fn_vb(linf, k, v_vb_a_tma, t_0)
#plot(v_vb_a_tma, v_vb_l_tma)

```

#####Weight-Length Conversion

$W = aL^b$

Variable   | Definition
---------- | ---------------------------
*W*        | Weight (Grams)
*a*        | Length (Millimeters)
*L*        | Parameter
*b*        | Parameter

```{r lw_function}

# Generic length-to-weight conversion. 
fn_lw = function(a, l, b){w = a * l ^ b
                          return(w)}

# White seabass demo in mm:g.
v_lw_l_wsb = seq(0, 1500, by = 100)
v_lw_w_wsb = fn_lw(0.000015491, v_lw_l_wsb, 2.92167)
plot(v_lw_l_wsb, v_lw_w_wsb)

# Totoaba demo.
#v_lw_l_tma = seq(l0, linf, by = 100)
#v_lw_w_tma = fn_lw(a, v_lw_l_tma, b)
#plot(v_lw_l_tma, v_lw_w_tma)

```

#####Weight-Maw Conversion

For a stock of $n_{a, t}$ totoaba cultivated for *a* years in year *t* to weight $w_{a, t}$ for a total round weight of $x_{a, t}$, maw yield $y_{a, t}$ depends on wet maw yield ratio $c^{maw}_{a, t}$ and dry yield ratio $k$.

$y^{maw}_{a, t} = w_{a, t}n_{a, t}c^{maw}_{a, t}k^{maw}_{dry}$

Variable   | Definition
---------- | --------------------------------
$y^{maw}$  | Cohort Dry Maw Yield (Kilograms)
*w*        | Individual Round Weight (Kilograms)
*n*        | Cohort Count
$c^{maw}$  | Yield of maw from round weight.
$k^{maw}$  | Yield of dry maw from wet maw.

```{r wm_function}

fn_wm = function(w, n, c, k){ymaw = w * n * c * k
                             return(ymaw)}

```

#####Maw-Price Conversion

Plug the market model in here.

```{r mp_function}

#fn_mp = function(w, b0, bw, bq, q, bc, c){pmaw = b0 + w ^ bw + bq * q + bc * c}
fn_mp = function(w, b0, b){pmaw = b0 + w^b
                           return(pmaw)}

```

#####Maw-Revenue Conversion

Fix from regression specification. See Maw-Price Conversion.

For a dry maw yield $y^{maw}$ in kilograms, revenue depends on price.

$R^{maw}_{a, t} = x_{a, t}/n_{a, t} * (\beta_0 + \beta_{g}(x_{a, t}/n_{a, t}))$

```{r mr_function}

fn_mr = function(ymaw, pmaw){rmaw = ymaw * pmaw
                             return(rmaw)}

```

#####Round-Revenue Conversion

For a stock of *n* totoaba cultivated for *a* years in year *t* for an individual round weight of $w_{a, t}$, revenue depends on price.

$R^{round}_{a, t} = w_{a, t} * n_{a, t} * p^{round}$

```{r wr_function}

fn_fr = function(w, n, pround){rround = w * n * pround
                               return(rround)}

```

#####Feed Conversion Function

Check in with Goto. Fix.

```{r fcr_function}

#fn_fcr = function(w, fcr){}

```


#####No-Harvest Cost

Fix FCR, then fix this.

```{r c_stock}

# Feed costs for a cohort.

fn_ch0 = function(w, cstock, n){ch0 = w * n * cstock
                                return(ch0)}#{cstock = ccoeff * a ^ cexp}

```


#####Harvest Cost

Cost of restocking a cage after harvest. USD?

```{r c_restock}

# Cost of fry plus overhead.

#fn_ch1 = function(){}

```


#####Single Run, No-Harvest Demo

```{r demo_noharvest}

t = seq(0, 25)
l = fn_vb(1465.3822, 0.1280, t, -0.2805)
w = fn_lw(0.000015491, l, 2.92167)
ymaw = fn_wm(w, 1000, 0.40, 0.02)
pmaw = fn_mp(w, 25, 1.75)
rmaw = fn_mr(ymaw, pmaw)
rround = fn_fr(w, 1000, 2.50)
r = rround + rmaw
c = (10000 * w)^1.5

demo_h0 = data.frame(t, r, c)

demo_h0 = melt(demo_h0, id = 1)

ggplot(demo_h0, aes(t, value, colour = variable)) +
  geom_path()


```


#####Single Run, Harvest Demo

```{r demo_harvest, eval = FALSE, include = FALSE}

# Duplicating structure from fishery demo - do not run without changes.

# Define parameters for each low-level function to easily run the high-level function.
var = c("start", 
        "end", 
        "linf", 
        "k",
        "t0", 
        "a", 
        "b", 
        "n0", 
        "yround", 
        "ywet", 
        "b0", 
        "b1",
        "pround", 
        #"c_coeff",
        #"c_exp",
        "c_stock",
        "c_restock")


par = c(1, 
        25, 
        1465, 
        0.1280, 
        -0.2805,
        0.000015491,
        2.92167,
        1000,
        0.4,
        0.02,
        25,
        1.75,
        2.50,
        #10000,
        #2.00,
        10,
        200000)

fun = c(rep("All", 2), 
        rep("Age-Length", 3),
        rep("Length-Weight", 2),
        rep("Weight-Maw", 3),
        rep("Maw-Price", 2),
        "Weight-Revenue (Round)",
        #rep("No-Harvest Cost", 2), 
        "No-Harvest Cost",
        "Harvest Cost")

num = seq(1, length(var))

tab = data.frame(num, fun, var, par)

kable(tab)
```

```{r whatever}
#q_aq = function(r, k, q, p, c, eta, x0, e0, start, end){
#                     x = as.numeric(vector(length = (end - start)))
#                     x[1] = x0
#                     e = as.numeric(vector(length = (end - start)))
#                     e[1] = e0
#                     T = length(seq(start, end))
#                     t = seq(start, end)
#            for (i in 2:T){x[i] = x[i-1] * ( 1 + r - r * x[i-1] / k - q * e[i-1])
#                           e[i] = e[i-1] * ( 1 + eta * ( p * q * x[i-1] - c))}
#                     return(x)}

# Define a function for aquaculture output over time for one cage.
aq = function(par){t = as.numeric(vector(length = par[2]))
                   h = as.numeric(vector(length = par[2]))
                   hinv = as.numeric(vector(length = par[2]))
                   a = as.numeric(vector(length = par[2]))
                   l = as.numeric(vector(length = par[2]))
                   w = as.numeric(vector(length = par[2]))
                   n = as.numeric(vector(length = par[2]))
                   y = as.numeric(vector(length = par[2]))
                   n = as.numeric(vector(length = par[2]))
                   p = as.numeric(vector(length = par[2]))
                   rmaw = as.numeric(vector(length = par[2]))
                   rround = as.numeric(vector(length = par[2]))
                   r = as.numeric(vector(length = par[2]))
                   c = as.numeric(vector(length = par[2]))
                  
                   t[1] = par[1]
                   h[1] = 0
                   hinv[1] = 1
                   a[1] = t[1]
                   l[1] = fn_vb(par[3], par[4], t[1], par[5])
                   w[1] = fn_lw(par[6], l[1], par[7])
                   n[1] = par[8]
                   y[1] = fn_wm(w[1], n[1], par[9], par[10])
                   p[1] = fn_mp(w[1], par[11], par[12])
                   rmaw[1] = y[1] * p[1]
                   rround[1] = w[1] * par[13]
                   r[1] = (rmaw[1] + rround[1]) * h[1]
                   c[1] = fn_ch0(w[1], par[14], n[1])
                  
                   for(i in 2:par[2]){
                     t[i] = t[i - 1] + 1
                     h[i] = 0
                     hinv[i] = (h[i] - 1) ^ 2
                     a[i] = a[i - 1] * hinv[i - 1] + 1
                     l[i] = fn_vb(par[3], par[4], a[i], par[5])
                     w[i] = fn_lw(par[6], l[i], par[7])
                     n[i] = par[8]
                     y[i] = fn_wm(w[i], n[i], par[9], par[10])
                     p[i] = fn_mp(w[i], par[11], par[12])
                     rmaw[i] = y[i] * p[i]                         # Fix yield-revenue function for maw.
                     rround[i] = fn_fr(w[i], n[i], par[13])
                     r[i] = (rmaw[i] + rround[i]) * h[i]
                     c[i] = fn_ch0(w[i], par[14], n[i]) * hinv[i] + par[15] * h[i]
                     }
                   
                  output = tibble(t, h, a, l, w, n, y, p, rmaw, rround, r, c)

                  return(output)}

output = aq(par)

trim = tibble(output$t, output$rmaw, output$c)

use = melt(trim, id = 1)

colnames(use) = c("t", "val", "var")

ggplot(use, aes(t, var, colour = val)) +
  geom_path()

```

