---
title: "Aquaculture Model"
date: '`r Sys.Date()`'
output: html_document
---

```{r pkg_ins, warning = FALSE, message = FALSE, echo = FALSE, results = 'hide'}

rm(list=ls())

# Check out knitr for knitr::read_chunk.
library(knitr)

# Name packages.
pkg <- c("readr",
         "knitr",
         "tidyverse",
         "gapminder",
         "sandwich",
         "broom",
         "stargazer",
         "cowplot",
         "kableExtra",
         "reshape2",
         "devtools")

# Install packages.
#install.packages(pkg, verbose = FALSE, quiet = TRUE)
#devtools::install_github("AckerDWM/gg3D")
  
# Update packages.
#update.packages(pkg, verbose = FALSE, quiet = TRUE)

# Check out packages.
invisible(lapply(pkg, library, character.only = TRUE))

#library(gg3D)
```

```{r btheme_present, echo = FALSE}

btheme_present =
  theme(plot.title = element_text(hjust = 0.5, size = 32, family = "Century Gothic", face = "bold"), 
        rect = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA),
        legend.position = "right",
        legend.background = element_rect(fill = "transparent"),
        legend.box.background = element_rect(fill = "transparent"),
        legend.key = element_rect(fill="transparent", colour=NA),
        legend.text = element_text(size = 16, family = "Century Gothic"),
        legend.title = element_text(size = 18, family = "Century Gothic"),
        panel.background = element_rect(fill = "transparent"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(size = 18, family = "Century Gothic"),
        axis.title.x = element_text(size = 24, family = "Century Gothic", face = "bold"),
        axis.text.y = element_text(size = 18, family = "Century Gothic"),
        axis.title.y = element_text(size = 24, family = "Century Gothic", face = "bold"))

```

```{r btheme_paper, echo = FALSE}

btheme_paper =
  theme(plot.title = element_text(hjust = 0.5, size = 14, family = "Century Gothic", face = "bold"), 
        rect = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA),
        legend.position = "right",
        legend.background = element_rect(fill = "transparent"),
        legend.box.background = element_rect(fill = "transparent"),
        legend.key = element_rect(fill="transparent", colour=NA),
        legend.text = element_text(size = 12, family = "Century Gothic"),
        legend.title = element_text(size = 14, family = "Century Gothic"),
        panel.background = element_rect(fill = "transparent"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(size = 8, family = "Century Gothic"),
        axis.title.x = element_text(size = 10, family = "Century Gothic", face = "bold"),
        axis.text.y = element_text(size = 8, family = "Century Gothic"),
        axis.title.y = element_text(size = 10, family = "Century Gothic", face = "bold"))

```


###Objective: Step through optimal rotations for a generic totoaba farm.

####Introduction
Our objective requires functions and inputs for the growth, mortality, trimming, and harvest of totoaba over *n* cages.

We first build out intermediate functions to find both constant and variable parameter values.

These are:

1. Lengths at Age
2. Mortalities at Age
3. Weights at Length
4. Numbers at Age
5. Maw Yields at Length
6. Maw Prices at Weight
7. Maw Revenues at Weight and Price
8. Meat Revenues at Weight
9. Feed Requirements at Weight | No-Harvest Cost
10. Feed Requirement at Stocking | Harvest Cost

We next compile bioeconomic inputs, intermediate results, and additional parameters for an iterative Faustmann model.

We program and run the Faustmann model for a single cage, ~~then for multiple cages, and finally for a sensitivity analysis~~.

Lastly, we create figures for intermediate calculations and results of the Faustmann model.

####Lengths at Age

We estimate lengths at age from a Von Bertalanffy function.

Our parameter estimates follow from INAPESCA (2018) and EOF (2018). **This section needs the whole estimation process from Excel.**

$L(t) = L_\infty ( 1 - e^{ - K ( t - t_0 )})$

Variable   | Definition                   | Value
---------- | ---------------------------  | ---------
*L*        | Length (Centimeters)         | 
$L_\infty$ | Maximum Length (Centimeters) | 180.0000
$K_{fi}$   | Catabolic Constant (INAPESCA)| 0.155000
$K_{aq}$   | Catabolic Constant (EOF)     | 0.228560
*t*        | Age (Years)                  | 
$t_0$      | Age, *L* = 0                 | 0.000000

```{r al_function}

# Von Bertalanffy function.
fn_vb = function(linf, k, t, t_0){l = linf * ( 1 - exp( - k * ( t - t_0)))}

# Set parameter values for future reference.
vb_linf = 200
vb_k    = 0.155 #0.22856
vb_t0   = -0.65

```

####Mortalities at Age

We estimate mortalities at age from a report by month over two years from Cygnus Ocean Farms, SA de CV.

Supposing a mortality trend $m = \beta_1 * e^{\beta_2a}$, we use R function stats::nls to estimate parameters.
 
```{r am_data}

a_months = seq(1, 24)
m_months = c(rep(5.00, 2), 
             rep(2.40, 2), 
             rep(1.60, 2), 
             rep(1.15, 2), 
             rep(1.00, 3), 
             rep(0.80, 3), 
             0.50, 
             rep(0.40, 6), 
             0.30, 
             rep(0.20, 2))

dat_m = tibble(a_months, m_months)

# Specification for nonlinear regression:
am_reg = nls(m_months ~ b1 * exp(b2 * a_months), dat_m, start = list(b1 = 8.00, b2 = - 1.00))

# Clean up output:
am_reg_tidy = tidy(am_reg, conf.int = TRUE, conf.level = 0.95)
dat_m_est = augment(am_reg)

```

Results plug into a function:

$M = \beta_1 * e^{\beta_2a}$

Variable   | Definition                  | Value
---------- | --------------------------- | -----------
*m*        | Cohort Mortality (%)        |
*a*        | Age (Months)                |
$\beta_1$  | Parameter                   | `r am_reg_tidy$estimate[1]`
$\beta_2$  | Parameter                   | `r am_reg_tidy$estimate[2]`

We annualize mortalities at age to match other data.

To keep a realistic non-zero mortality-at-age estimate, we add an annualized proportional mortality of 0.01.

The indefinite integral of mortality-at-age, i.e. cumulative mortality, is also defined as:
$M = \frac{\beta_1 * e^{\beta_2a}}{\beta_2}$

```{r am_function}

# Set marginal mortality.
fn_am_marg = function(a, b1, b2){m = b1 * exp(b2 * a * 12) + 1} # "+ 1" adds lower threshold of 0.01 on mortality.
                                                                # "* 12" converts from months to years.

# Set parameters for reference.
am_b1 = am_reg_tidy$estimate[1]
am_b2 = am_reg_tidy$estimate[2]

```

####Weights at Length

We estimate weights at age from a functional form and parameters values from INAPESCA (2018). **Hey Miguel, is this right?**

$W = aL^b$

Variable   | Definition                  | Value
---------- | --------------------------- | -------
*W*        | Weight (Kilograms)          |
*L*        | Length (Centimeters)        |
*a*        | Parameter                   | 0.000004128
*b*        | Parameter                   | 3.246740000

```{r lw_function}

# Generic length-to-weight conversion. 
fn_lw = function(a, l, b){w = a * l ^ b
                          return(w)}

# Set parameter values for future reference.
wl_a = 0.000004128
wl_b = 3.24674

```

####Numbers at Age

After mortality, any biomass in excess of optimal stocking density is harvested. Optimal density is 160,000 kilograms per cage at and after first salable size. First salable size is two kilograms. **We use optimal stocking density from ?!?!?! and HSWRI (2019).** Implementation of trimming in the Faustmann model is only calculated in the model itself, not in an intermediate function.

$T = n_t^* - n_{t-1}^* * m_{t-1}$

```{r ac_calc}

# Density is highest possible kilograms per cubic meter without density-dependence slowing growth.
density = 160000 # Goto or Miguel - is this from Felipe?

# Size is first saleable size in kilograms.
size = 2 # Communications with EOF (2018).

a = seq(1, 25)
w = fn_lw(wl_a, fn_vb(vb_linf, vb_k, a, vb_t0), wl_b)
fn_ns = function(density, w){ns = density / w} # Note lag on age to get last year's mortality.

# Cohort count at first saleable size is the ratio of density in kgm^-3 to size in kg.
nsale = density / size

# Initial cohort count is density at first saleable size, plus cumulative mortality at first saleable age.
# Casually, nstart = nsale + mort(a(l(wsale))).
# Cumulative mortality to first saleable age:
a_sale = (vb_t0 - 1 / vb_k * (log(1 - ((size / wl_a) ^ (1 / wl_b))/vb_linf))) # Inverse Von Bertalanffy.

# Initial stock to reach optimal density at first salable size:
nstart = nsale * (100 / (100 - fn_am_marg(a_sale, am_b1, am_b2))) * 
  (100 / (100 - fn_am_marg(1, am_b1, am_b2))) * 
  (100 / (100 - fn_am_marg(1, am_b1, am_b2)))

```

####Maw Weights at Individual Weight

For a stock of $n_{a, t}$ totoaba cultivated for *a* years in year *t* to weight $w_{a, t}$ for a total round weight of $x_{a, t}$, maw yield $y_{a, t}$ depends on wet maw yield ratio $c^{maw}_{a, t}$ and dry yield ratio $k$.

$y^{maw}_{a, t} = w_{a, t}n_{a, t}c^{maw}_{a, t}k^{maw}_{dry}$

Variable   | Definition                          | Value
---------- | ----------------------------------- | ----------
$y^{maw}$  | Cohort Dry Maw Yield (Kilograms)    | 
*w*        | Individual Round Weight (Kilograms) |
*n*        | Cohort Count                        |
$c^{maw}$  | Yield of maw from round weight.     | 0.0161
$k^{maw}$  | Yield of dry maw from wet maw.      | 0.3100

```{r wm_function}

fn_wm = function(w, n, c, k){ymaw = w * n * c * k}

# Parameters from cultivated sample (UABC & PhD) and from inapesca wild sample:
wm_c = 0.0161
wm_k = 0.31

```

####Maw Prices at Maw Weight and Market Supply

We estimate price from multiple regression of price per gram of maw on tonnes of dry maw supplied and grams per maw.

```{r mp_function}

#fn_mp = function(w, b0, bw, bq, q, bc, c){pmaw = b0 + w ^ bw + bq * q + bc * c}
fn_mp = function(w, b0, b1, b2, q){pmaw = (q * b1 + (w * 1000) ^ b2 + b0) * 1000} # Factors of 1000 convert from grams to kilograms.

# Parameters from regression.
mp_b0 = 82.99177
mp_b1 = -5.28312
mp_b2 = 0.52540
mp_q = 10 # Note that 14 fills in for a reasonable quantity at market from poaching. In the Faustmann implementation, mp_q is lag quantity supplied.

```

####Maw Revenues at Maw Price and Yield

For a dry maw yield $y^{maw}$ in kilograms, revenue depends on price.

$R^{maw}_{a, t} = x_{a, t}/n_{a, t} * (\beta_0 + \beta_{g}(x_{a, t}/n_{a, t}))$

```{r mr_function}

fn_mr = function(ymaw, pmaw){rmaw = ymaw * pmaw}

```

####Wet Weight Revenues at Yield

For a stock of *n* totoaba cultivated for *a* years in year *t* for an individual round weight of $w_{a, t}$, revenue depends on price.

$R^{round}_{a, t} = w_{a, t} * n_{a, t} * p^{round}$

```{r wr_function}

fn_fr = function(w, n, pround){rround = w * n * pround}

# Parameter from market research:
pround = 6.50 # Price from Sistema Nacional de Informacion e Integracion de Mercados (2019)

```

####Feed Requirements at Weight

We assume a constant daily feed requirement proprotional to organism mass. 

Calculations for an alternative estimation of feed requirement follow.

```{r fcr_data, eval = FALSE, echo = FALSE}

dat_fcr = read.csv("fcr.csv")

# Convert values from grams to kilograms for later.
dat_fcr$weight = dat_fcr$weight / 1000
dat_fcr$feed = dat_fcr$feed / 1000

```

~~For reasons, we assume functional form $F = \beta_1 * w^{\beta_2}$~~

```{r fcr_results, eval = FALSE, echo = FALSE}

# Specification for nonlinear regression:
#fcr_reg = nls(feed ~ b1 * weight ^ b2, dat_fcr, start = list(b1 = 0.0268, b2 = - 1.855))

# Clean up output:
#fcr_reg_tidy = tidy(fcr_reg, conf.int = TRUE, conf.level = 0.95)
#dat_fcr_est = augment(fcr_reg)

```

Those results plug into a feed-at-weight function:

Variable   | Definition                  | Value
---------- | --------------------------- | -----------
*w*        | Weight (Kilograms)          |
*f*        | Cumulative Feed (Kilograms) |
$\beta_1$  | Parameter                   | 1.00
$\beta_2$  | Parameter                   | 0.01

For convenience below, the derivative of feed-at-weight, i.e. instantaneous feed requirement, is also defined as:
$f = \beta_1 \beta_2 w^{\beta_{1}-1}$

```{r fcr_function}

# Set cumulative feed requirement.
fn_f_cumu = function(w, b1, b2){F = b1 * w ^ b2}

# Set marginal feed requirement.
fn_f_marg = function(w, b1, b2){f = b1 * b2 * w}

# Set parameters for reference.
f_b1 = 0.01
f_b2 = 1.00

```

####No-Harvest Cost

We estimate the cost of maintaining a cohort in a cage from cohort size, cohort weight, marginal feed requirement, feed cost, and generalized overhead costs.

$c_{h = 0} = n_a * c_f * f(w) + o$

```{r c_stock}

# Marginal cohort cost.
fn_ch0 = function(w, b1, b2, cf, n, o){ch0 = n * cf * fn_f_marg(w, b1, b2) * 365 + o} # FCR is daily, so multiply by days.

# Parameters.
#  Cost, USD/kg.
ch0_cf = 2 # Intrafish (2019), pers. comm. Garrett Goto, Earth Ocean Farms S.A. de C.V. (2019).

# Overhead, from eight cages for ten years down to one cage for one year.
o = 170000

#pers. comm. Felipe Ramirez (10/16/2018), InnovaSea (11/5/2018); pers. comm. Tyler Korte (11/5/2018), Blue Ocean Mariculture; pers. comm. Earth Ocean Farms S.A. de C.V. (2018); Salary tabulator (2017 SHCP); Cygnus MIA (2017)

#Costs for 8 AquaPods per year over ten years include: AquaPods ($140,000), Accessories ($420,000), Maintainence ($100,000), Net Cleaning ($80,000), Feed Boat ($40,000), Harvest Boat ($40,000), Eight Pangas ($12,000), Fuel ($25,155), Farm Employees ($112,000), Office Employees ($80,000), Leasing ($150,000), Other/misc ($100,000), HR/Office ($50,000)

#Annual cost for 8 AquaPods (over 10 years) = $1,349,155
#Annual cost for 1 AquaPod (over 10 years) = $1,349,155/8 = $168,644.38

```

####Harvest Cost

We estimate the cost of harvesting with instantaneous restocking from optimal stocking density at first age for optimal stocking density at first salable age, cost of fry for restocking, and generalized overhead costs.

```{r c_restock}

ch1 = nstart * 2 + o # Fry Cost (CREMES).

```

####Intermediate Results Summary

With intermediate results ready for the Faustmann implementation, we run a few graphs out for later reference.

```{r intermediate, echo = FALSE}

# 1. Lengths at Age
#    Set-Up.
a = seq(1, 27)
l = fn_vb(vb_linf, vb_k, a, vb_t0)

#    Graph.
ggvb =
ggplot() +
  geom_path(aes(a, l), colour = "firebrick") +
  labs(x = "Age (Years)", y = "Length (Centimeters)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Lengths at Age") +
  theme_classic()

print(ggvb)

# 2. Mortalities at Age
#    Graph.
ggma =
ggplot(dat_m_est) +
  geom_point(aes(a_months, m_months)) +
  geom_path(aes(a_months, .fitted)) +
  labs(x = "Age (Months)", y = "Mortality (%)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Mortalities at Age") +
  theme_classic()

print(ggma)

# 3. Weights at Length
#    Set-Up
l = seq(0, 200, by = 10)
w = fn_lw(wl_a, l, wl_b)

#    Graph
gglw =
ggplot() +
  geom_path(aes(l, w), colour = "firebrick") +
  labs(x = "Length (Centimeters)", y = "Weight (Kilograms)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Weights at Length") +
  theme_classic()

print(gglw)

```

####Parameter Set-Up

With intermediate results ready to plug into the Faustmann model, everything goes into a vector for model runs and a table for handy external reference.

```{r pars, eval = FALSE, include = FALSE}

# Define parameters for each low-level function in a high-level function of multiple harvests over time.
var = c("start", 
        "end", 
        "linf", 
        "k",
        "t0", 
        "a", 
        "b", 
        "n0", 
        "yround", 
        "ywet", 
        "b0", 
        "b1",
        "b2",
        "q",
        "pround", 
        #"c_coeff",
        #"c_exp",
        "f_b1", 
        "f_b2", 
        "ch0_cf", 
        "o",
        "c_restock",
        "disc",
        "density",
        "am_b1",
        "am_b2",
        "nstart",
        "harvest",
        "maw")

par00 = c(1, 
          10, 
          vb_linf, 
          vb_k, 
          vb_t0,
          wl_a,
          wl_b,
          nstart,
          wm_c,
          wm_k,
          mp_b0,
          mp_b1,
          mp_b2,
          mp_q,
          pround,
          f_b1, 
          f_b2, 
          ch0_cf, 
          o,
          ch1,
          0.84,
          density,
          am_b1,
          am_b2,
          nstart,
          0,
          0)

par01 = par00
par01[27] = 1

par10 = par00
par10[26] = 1

par11 = par00
par11[27] = 1
par11[26] = 1

fun = c(rep("All", 2), 
        rep("Age-Length", 3),
        rep("Length-Weight", 2),
        rep("Weight-Maw", 3),
        rep("Maw-Price", 4),
        "Weight-Revenue (Round)",
        rep("No-Harvest Cost", 4),
        "Harvest Cost",
        "Discount Factor",
        rep("Density-Optimal Stocking", 4),
        "Harvest Switch",
        "Maw Switch")

num = seq(1, length(var))

tab = data.frame(num, fun, var, par00, par10, par01, par11)

# Save parameters to working directory.
#kable(tab, digits = 2) %>%
#  kable_styling() %>%
#  save_kable(file = "partab.html", self_contained = T)

```

####Single-Run Function

```{r fun, eval = FALSE, include = FALSE}
# Define a function for dynamic harvests over time.
aq = function(par){t = as.numeric(vector(length = par[2]))  # First, initialize blank vectors for each variable.
                   a0 = as.numeric(vector(length = par[2]))
                   a1 = as.numeric(vector(length = par[2]))

                   h = as.numeric(vector(length = par[2]))
                   hinv = as.numeric(vector(length = par[2]))
                   
                   l0 = as.numeric(vector(length = par[2]))
                   w0 = as.numeric(vector(length = par[2]))
                   nm0 = as.numeric(vector(length = par[2]))
                   ns0 = as.numeric(vector(length = par[2]))
                   nt0 = as.numeric(vector(length = par[2]))
                   n0 = as.numeric(vector(length = par[2]))
                   rt0 = as.numeric(vector(length = par[2]))
                   y0 = as.numeric(vector(length = par[2]))
                   p0 = as.numeric(vector(length = par[2]))
                   rmaw0 = as.numeric(vector(length = par[2]))
                   rround0 = as.numeric(vector(length = par[2]))
                   r0 = as.numeric(vector(length = par[2]))
                   c0 = as.numeric(vector(length = par[2]))
                   
                   l1 = as.numeric(vector(length = par[2]))
                   w1 = as.numeric(vector(length = par[2]))
                   nm1 = as.numeric(vector(length = par[2]))
                   ns1 = as.numeric(vector(length = par[2]))
                   nt1 = as.numeric(vector(length = par[2]))
                   n1 = as.numeric(vector(length = par[2]))
                   rt1 = as.numeric(vector(length = par[2]))
                   y1 = as.numeric(vector(length = par[2]))
                   p1 = as.numeric(vector(length = par[2]))
                   rmaw1 = as.numeric(vector(length = par[2]))
                   rround1 = as.numeric(vector(length = par[2]))
                   r1 = as.numeric(vector(length = par[2]))
                   c1 = as.numeric(vector(length = par[2]))
                   
                   r = as.numeric(vector(length = par[2]))
                   c = as.numeric(vector(length = par[2]))
                  
                   t[1] = par[1] # Plug a starting value into each vector's first cell.
                   a0[1] = t[1]
                   a1[1] = a0[1] + 1
                   
                   h[1] = 0
                   hinv[1] = 1
                   
                   l0[1] = fn_vb(par[3], par[4], t[1], par[5])
                   w0[1] = fn_lw(par[6], l0[1], par[7])
                   nm0[1] = nstart * (0.01 * fn_am_marg(a0[1], par[23], par[24]))
                   ns0[1] = nstart * (1 - 0.01 * fn_am_marg(a0[1], par[23], par[24])) # Note leading mortality.
                   nt0[1] = ifelse(ns0[1] - fn_ns(par[22], w0[1]) > 0, ns0[1] - fn_ns(par[22], w0[1]), 0)
                   n0[1] = nstart - nm0[1] - nt0[1]
                   rt0[1] = fn_fr(w0[1], nt0[1], par[15])
                   y0[1] = fn_wm(w0[1], n0[1], par[9], par[10])
                   p0[1] = fn_mp(w0[1], par[11], par[12], par[13], par[14] + y0[1] / 1000) * 0.10 # Note price transformation.
                   rmaw0[1] = y0[1] * p0[1]
                   rround0[1] = w0[1] * par[15]
                   r0[1] = (rmaw0[1] + rround0[1])
                   c0[1] = fn_ch0(w0[1], par[16], par[17], par[18], par[8], par[19])

                   l1[1] = fn_vb(par[3], par[4], 2, par[5])
                   w1[1] = fn_lw(par[6], l1[1], par[7])
                   # Since this implementation of mortality/survival and trimming require iteration to work, the corresponding lead variables are spaghetti.
                   nm1[1] = (nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24])) - 
                               ifelse(nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24]) - fn_ns(par[22], w1[1])) > 0, 
                                      nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24]) - fn_ns(par[22], w1[1])), 
                                      0)) * (0.01 * fn_am_marg(a1[1], par[23], par[24]))
                   ns1[1] = (nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24])) - 
                               ifelse(nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24]) - fn_ns(par[22], w1[1])) > 0, 
                                      nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24]) - fn_ns(par[22], w1[1])), 
                                      0)) * (1 - 0.01 * fn_am_marg(a1[1], par[23], par[24])) # Note leading mortality
                   nt1[1] = ifelse(ns1[1] - fn_ns(par[22], w1[1]), ns1[1] - fn_ns(par[22], w1[1]), 0)
                   n1[1] = fn_ns(density, w1[1])
                   rt1[1] = fn_fr(w1[1], nt1[1], par[15])
                   y1[1] = fn_wm(w1[1], n1[1], par[9], par[10])
                   p1[1] = fn_mp(w1[1], par[11], par[12], par[13], par[14] + y1[1] / 1000) * 0.10 # Note price transformation.
                   rmaw1[1] = y1[1] * p1[1]
                   rround1[1] = w1[1] * par[15]
                   r1[1] = (rmaw1[1] + rround1[1])
                   c1[1] = fn_ch0(w1[1], par[16], par[17], par[18], par[8], par[19])
                   
                   r[1] = r0[1]
                   c[1] = c0[1]
                  
                   # With vectors to fill and initial values to loop from, loop through periods of interest. i is years.                   
                   for(i in 2:par[2]){
                     t[i] = t[i - 1] + 1
                     
                     a0[i] = a0[i - 1] * hinv[i - 1] + 1
                     a1[i] = a0[i] + 1
                     
                     l0[i] = fn_vb(par[3], par[4], a0[i], par[5])
                     w0[i] = fn_lw(par[6], l0[i], par[7])
                     nm0[i] = (nstart * h[i - 1] + n0[i - 1] * hinv[i - 1]) * (0.01 * fn_am_marg(a0[i], par[23], par[24])) # Note leading mortality.
                     ns0[i] = (nstart * h[i - 1] + n0[i - 1] * hinv[i - 1]) * (1 - 0.01 * fn_am_marg(a0[i], par[23], par[24])) # Note leading mortality.
                     nt0[i] = ifelse(ns0[i] - fn_ns(par[22], w0[i]) > 0, ns0[i] - fn_ns(par[22], w0[i]), 0)
                     n0[i] = (nstart * h[i - 1] + n0[i - 1] * hinv[i - 1]) - nm0[i] - nt0[i]
                     rt0[i] = fn_fr(w0[i], nt0[i], par[15])
                     y0[i] = fn_wm(w0[i], n0[i], par[9], par[10])
                     p0[i] = fn_mp(w0[i], par[11], par[12], par[13], par[14] + y0[i - 1] / 1000) * 0.10 # Note price transformation.
                     rmaw0[i] = y0[i] * p0[i]
                     rround0[i] = fn_fr(w0[i], n0[i], par[15])
                     r0[i] = par[27] * rmaw0[i] + rround0[i]
                     c0[i] = fn_ch0(w0[i], par[16], par[17], par[18], n0[i], par[19])
                     
                     l1[i] = fn_vb(par[3], par[4], a1[i], par[5])
                     w1[i] = fn_lw(par[6], l1[i], par[7])
                     nm1[i] = (nstart * h[i - 1] + n1[i - 1]) * hinv[i - 1] * (0.01 * fn_am_marg(a1[i], par[23], par[24])) # Note leading mortality.
                     ns1[i] = (nstart * h[i - 1] + n1[i - 1]) * hinv[i - 1] * (1 - 0.01 * fn_am_marg(a1[i], par[23], par[24])) # Note leading mortality.
                     nt1[i] = ifelse(ns1[i] - fn_ns(par[22], w1[i]) > 0, ns1[i] - fn_ns(par[22], w1[i]), 0)
                     n1[i] = (nstart * h[i - 1] + n1[i - 1] * hinv[i - 1]) - nm1[i] - nt1[i]
                     rt1[i] = fn_fr(w1[i], nt1[i], par[15])
                     y1[i] = fn_wm(w1[i], n1[i], par[9], par[10])
                     p1[i] = fn_mp(w1[i], par[11], par[12], par[13], par[14] + y1[i - 1] / 1000) * 0.10 # Note price transformation.
                     rmaw1[i] = y1[i] * p1[i]
                     rround1[i] = fn_fr(w1[i], n1[i], par[15])
                     r1[i] = rmaw1[i] + rround1[i]
                     c1[i] = fn_ch0(w1[i], par[16], par[17], par[18], n1[i], par[19])
                     
                     # Mind wrapper for hard-coding lower bound age at harvest.
                     h[i] = par[26] * ifelse(a0[i] > 0, ifelse((r0[i] - par[20]) > (par[21] * (r1[i] - c0[i] + rt0[i])), 1, 0), 0) # Think hard about lags here.
                     hinv[i] = (h[i] - 1) ^ 2
                     
                     r[i] = (r0[i] + rt0[i] * hinv[i])
                     c[i] = c0[i] * hinv[i] + par[20] * h[i]
                     
                     }
                    
                    output = tibble(t, c, r, p0, w0, n0, h, r0, r1, rround0, rt1, )

                  return(output)}

output2 = aq(par10)

write.csv(output2, "output2.csv")


```

####Run 11 + Profit

```{r run11, eval = FALSE, include = FALSE}

# Run the dynamic harvest demo from parameters.
output = aq(par11)

tibble_rc = output %>% 
  select(-h) %>% 
  melt(id = 1) %>% 
  rename(t = t, var = variable, val = value)

# Plot cumulative revenues and costs through harvest cycles.
h = ggplot(tibble_rc, aes(t, val, color = var)) +
      geom_path() +
      labs(x = "Years", y = "USD2018") +
      #scale_x_continuous(expand = c(0, 0), limits = c(1, 25)) +
      #scale_y_continuous(expand = c(0, 0), limits = c(0, 300000000), labels = scales::comma) +
      #ggtitle("Costs and Revenues for One Cage - Trimming and Harvest") +
      theme_classic() +
      theme(axis.text.x = element_text(size = 8),
          axis.text.y = element_text(size = 8),
          #legend.text = element_text(size = 8),
          axis.title.x = element_text(size = 9),
          axis.title.y = element_text(size = 9),
          #legend.title = element_text(size = 9),
          plot.title = element_text(size = 9))#,
          #legend.position = "none")

# Save harvest plot to working directory.
#ggsave("h1plot.png", plot = h, dpi = 300, width = 6.5, height = 4.5)

# Save output to working directory.
#kable(output) %>%
#  kable_styling() %>%
#  save_kable(file = "htab.html", self_contained = T)

# Calculate and plot profit.
tbl_pi = output %>% 
  mutate(c1 = lead(c)) %>% 
  filter(!is.na(c1)) %>% 
  mutate(mc = ifelse(c1 - c > 0, c1 - c, 0)) %>% 
  mutate(rsale = r * h) %>% 
  mutate(pi = rsale - mc)

#plot(tbl_pi$t, tbl_pi$pi)

# Calculate and plot cumulative profit.
pi_sum = as.numeric(vector(length = par00[2] - 1))
pi_sum[1] = 0

for(i in 2:9){pi_sum[i] = tbl_pi$r[i] * tbl_pi$h[i] - tbl_pi$mc[i] + pi_sum[i - 1]} # par[2] for length

tbl_pi = cbind(tbl_pi, pi_sum)

# Add a column for color by vertical position.
tbl_pi = mutate(tbl_pi, color = ifelse(pi_sum > 0, 1, 0))

# Basic plot.  
#plot(tbl_pi$t, tbl_pi$pi_sum)

# Better plots.
pimargplot =
ggplot(tbl_pi, aes(t, pi)) +
  geom_path() +
  labs(x = "Years", y = "USD2018") +
      #scale_x_continuous(expand = c(0, 0), limits = c(1, 24)) +
      #scale_y_continuous(expand = c(0, 0), limits = c(-200000000, 600000000), labels = scales::comma) +
      #ggtitle("Annual Profit for One Cage - Harvest and Trimming, No Trimming Revenue") +
      theme_classic() +
      theme(axis.text.x = element_text(size = 8),
          axis.text.y = element_text(size = 8),
          #legend.text = element_text(size = 8),
          axis.title.x = element_text(size = 9),
          axis.title.y = element_text(size = 9),
          #legend.title = element_text(size = 9),
          plot.title = element_text(size = 9),
          legend.position = "none")

picumuplot =
ggplot(tbl_pi, aes(t, pi_sum)) +
  geom_path() +
  labs(x = "Years", y = "USD2018") +
      #scale_x_continuous(expand = c(0, 0), limits = c(1, 24)) +
      #scale_y_continuous(expand = c(0, 0), limits = c(-200000000, 600000000), labels = scales::comma) +
      #ggtitle("Cumulative Profit for One Cage - Harvest and Trimming, No Trimming Revenue") +
      theme_classic() +
      theme(axis.text.x = element_text(size = 8),
          axis.text.y = element_text(size = 8),
          #legend.text = element_text(size = 8),
          axis.title.x = element_text(size = 9),
          axis.title.y = element_text(size = 9),
          #legend.title = element_text(size = 9),
          plot.title = element_text(size = 9),
          legend.position = "none")

# Save!

#ggsave("pimplot.png", plot = pimargplot, dpi = 300, width = 6.5, height = 4.5)
#ggsave("picplot.png", plot = picumuplot, dpi = 300, width = 6.5, height = 4.5)

```

####Presentation Figures

```{r run00_costs_presentation, eval = FALSE, include = FALSE}

# Run the dynamic harvest demo from parameters.
output = aq(par00)

output = select(output, t, c)

# Reference .csv written from model output in console to save time.
#output = read.csv("cagecost_20190201.csv")

tibble_rc = output %>% 
  #select(-X) %>% 
  #select(-h, -p0) %>% 
  melt(id = 1) %>% 
  rename(t = t, var = variable, val = value) %>% 
  mutate(val = val * 0.000001)

# Plot cumulative revenues and costs through harvest cycles.

## Presentation Graph
cost_present = ggplot(tibble_rc, aes(t, val)) +
      geom_line(size = 3, color = "#1F4E79") +
      annotate("text", x = 8.5, y = 1.15, label = "Costs", size = 9, family = "Century Gothic") +
      scale_x_continuous(limits = c(1, 10), breaks = c(1, 2, 10), expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 3.000000), labels = scales::comma, expand = c(0, 0)) +
      theme_classic() +
      #ggtitle("Costs for One Cage") +
      labs( x = "Years", y = "Millions USD") +
      btheme_present

ggsave("cagecost_20190201_present.png",
       width = 720, 
       height = 490, 
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

## Paper Graph 
cost_paper = ggplot(tibble_rc, aes(t, val)) +
      geom_line(size = 2, color = "#1F4E79") +
      annotate("text", x = 8.5, y = 1.15, label = "Costs", size = 6, family = "Century Gothic") +
      scale_x_continuous(limits = c(1, 10), breaks = c(1, 2, 10), expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 3.000000), labels = scales::comma, expand = c(0, 0)) +
      theme_classic() +
      #ggtitle("Costs for One Cage") +
      labs( x = "Years", y = "Millions USD") +
      btheme_paper

ggsave("cagecost_20190201_paper.png",
       width = 5, 
       height = 3,
       units = c("in"),
       dpi = 300, 
       device = "png", 
       limitsize = FALSE, 
       bg = "transparent")



```

```{r growthrates, eval = FALSE, include = FALSE}

fn_vb = function(linf, k, t, t_0){l = linf * ( 1 - exp( - k * ( t - t_0)))}

# Set parameter values for future reference.
vb_linf = 200 # From 180 to 200.
vb_k_slow = 0.155
vb_k_fast = 0.22856
vb_t0   = -0.65

fn_lw = function(a, l, b){w = a * l ^ b
                          return(w)}

# Set parameter values for future reference.
wl_a = 0.000004128
wl_b = 3.24674

# Run out vector of ages.
a = seq(0, 27)
w_slow = fn_lw(wl_a, fn_vb(vb_linf, vb_k_slow, a, vb_t0), wl_b)
w_fast = fn_lw(wl_a, fn_vb(vb_linf, vb_k_fast, a, vb_t0), wl_b)

weights = data.frame(a, w_slow, w_fast)

## Presentation Graph

w_plot_present = ggplot(weights) +
      geom_line(aes(a, w_slow), size = 3, color = "#1F4E79") +
      geom_line(aes(a, w_fast), size = 3, color = "#F4B183") +
      annotate("text", x = 23, y = 105, label = "Wild", size = 9, family = "Century Gothic") +
      annotate("text", x = 23, y = 128, label = "Aquaculture", size = 9, family = "Century Gothic") +
      labs(x = "Years", y = "Kilograms") +
      scale_x_continuous(limits = c(0, 27), breaks = c(0, 10, 20, 27), expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 150), labels = scales::comma, expand = c(0, 0)) +
      theme_classic() +
      btheme_present

ggsave("weights_20190201_present.png",
       width = 720, 
       height = 490, 
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")


## Paper Graph 
w_plot_present = ggplot(weights) +
      geom_line(aes(a, w_slow), size = 2, color = "#1F4E79") +
      geom_line(aes(a, w_fast), size = 2, color = "#F4B183") +
      annotate("text", x = 23, y = 105, label = "Wild", size = 3, family = "Century Gothic") +
      annotate("text", x = 23, y = 128, label = "Aquaculture", size = 3, family = "Century Gothic") +
      labs(x = "Years", y = "Kilograms") +
      scale_x_continuous(limits = c(0, 27), breaks = c(0, 10, 20, 27), expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 150), labels = scales::comma, expand = c(0, 0)) +
      theme_classic() +
      btheme_paper

ggsave("weights_20190201_paper.png",
       width = 5, 
       height = 3,
       units = c("in"),
       dpi = 300, 
       device = "png", 
       limitsize = FALSE, 
       bg = "transparent")

write.csv(weights,"weights.csv")

```

```{r meatprofit, eval = FALSE, include = FALSE}

# Run the dynamic harvest demo from parameters.
output = aq(par10)

tibble_rc = output %>% 
  select(t, Revenue = r, Cost = c) %>% 
  #select(-h, -p0) %>% 
  melt(id = 1) %>% 
  rename(t = t, var = variable, val = value) %>% 
  mutate(val = val * 0.000001)

tibble_rc$val[1] = NA
#tibble_rc$val[4:10] = tibble_rc$val[3]


# Plot cumulative revenues and costs through harvest cycles.

##Presentation Graph
meat_present = ggplot(tibble_rc, aes(t, val, color = var)) +
      geom_segment(aes(x = 3, xend = 3, y = 0, yend = Inf), linetype = "dashed") +
      geom_path(size = 3) +
      annotate("text", x = 8.5, y = 1.15, label = "Costs", size = 9, family = "Century Gothic") +
      annotate("text", x = 9, y = 2.500000, label = "Revenues", size = 9, family = "Century Gothic") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      labs(x = "Years", y = " Millions USD", color = "") +
      scale_x_continuous(limits = c(1, 10), breaks = c(1, 2, 3, 10),expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 3.000000), labels = scales::comma, expand = c(0, 0)) +
      btheme_present +
      theme(legend.position = "none")

ggsave("meat_20190201_present.png", 
       width = 720, 
       height = 490, 
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

## Paper Graph

meat_paper = ggplot(tibble_rc, aes(t, val, color = var)) +
      geom_segment(aes(x = 3, xend = 3, y = 0, yend = Inf), linetype = "dashed") +
      geom_path(size = 2) +
      annotate("text", x = 8.5, y = 1.15, label = "Costs", size = 4, family = "Century Gothic") +
      annotate("text", x = 9, y = 2.500000, label = "Revenues", size = 4, family = "Century Gothic") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      labs(x = "Years", y = " Millions USD", color = "") +
      scale_x_continuous(limits = c(1, 10), breaks = c(1, 2, 3, 10),expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 3.000000), labels = scales::comma, expand = c(0, 0)) +
      btheme_paper +
      theme(legend.position = "none")

ggsave("meat_20190201_paper.png",
       width = 5, 
       height = 3,
       units = c("in"),
       dpi = 300, 
       device = "png", 
       limitsize = FALSE, 
       bg = "transparent")


```

```{r allprofit, eval = FALSE, include = FALSE}

# Run the dynamic harvest demo from parameters.
output = aq(par01)

tibble_rc = output %>% 
  select(t, Revenue = r, Cost = c) %>% 
  #select(-h, -p0) %>% 
  melt(id = 1) %>% 
  rename(t = t, var = variable, val = value) %>% 
  mutate(val = val * 0.000001)

tibble_rc$val[1] = NA

# Plot cumulative revenues and costs through harvest cycles.

##Presentation Graph 

mbpi_present = ggplot(tibble_rc, aes(t, val, color = var)) +
      geom_path(size = 3) +
      annotate("text", x = 8.5, y = 3, label = "Costs", size = 9, family = "Century Gothic") +
      annotate("text", x = 9, y = 31, label = "Revenues", size = 9, family = "Century Gothic") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      labs(x = "Years", y = "Millions USD", color = "") +
      scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(1, 2, 10)) +
      scale_y_continuous(expand = c(0, 0), limits = c(0, 35)) +
      theme_classic() +
      btheme_present +
      theme(legend.position = "none")

ggsave("mbpi_20190201_present.png", 
       width = 720, 
       height = 490, 
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

## Paper Graph

mbpi_paper = ggplot(tibble_rc, aes(t, val, color = var)) +
      geom_path(size = 2) +
      annotate("text", x = 8.5, y = 3, label = "Costs", size = 4, family = "Century Gothic") +
      annotate("text", x = 9, y = 31, label = "Revenues", size = 4, family = "Century Gothic") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      labs(x = "Years", y = "Millions USD", color = "") +
      scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(1, 2, 10)) +
      scale_y_continuous(expand = c(0, 0), limits = c(0, 35)) +
      theme_classic() +
      btheme_paper +
      theme(legend.position = "none")

ggsave("mpbi_20190201_paper.png",
       width = 5, 
       height = 3,
       units = c("in"),
       dpi = 300, 
       device = "png", 
       limitsize = FALSE, 
       bg = "transparent")


```

```{r slapdash, eval = FALSE, include = FALSE}

q = seq(0, 20)
p = 83 - 5.28 * q + 39.48 ^ 0.525
phh = ifelse(q < 11, 83 - 5.28 * 10 + 750 ^ 0.525, 83 - 5.28 * q + 750 ^ 0.525)
phl = ifelse(q < 15, 83 - 5.28 * 15 + 750 ^ 0.525, 83 - 5.28 * q + 750 ^ 0.525)
pth = ifelse(q < 15, 83 - 5.28 * 15 + 750 ^ 0.525, 83 - 5.28 * q + 750 ^ 0.525)
ptl = rep(0, 21)

slapdat = data.frame(q, p, phh, phl, pth, ptl)

## Presentation Graph

slapdash_present =
ggplot(data = slapdat) +
  geom_line(aes(q, p), color = "#1F4E79", size = 3) +
  labs(x = "Tonnes of Buche", y = "USD / Gram of Buche") +
  scale_x_continuous(expand = c(0, 0.125), breaks = c(0, 5, 10, 15, 17), limits = c(0, 17)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 90)) +
  #ggtitle("Demand for Dry Maw at First Harvest Size") +
  theme_classic() +
  btheme_present

#widescreen
ggsave("slapdash_present.png", 
       width = 720, 
       height = 490,   
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

## Paper Graph

slapdash_paper =
ggplot(data = slapdat) +
  geom_line(aes(q, p), color = "#1F4E79", size = 2) +
  labs(x = "Tonnes of Buche", y = "USD / Gram of Buche") +
  scale_x_continuous(expand = c(0, 0.125), breaks = c(0, 5, 10, 15, 17), limits = c(0, 17)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 90)) +
  #ggtitle("Demand for Dry Maw at First Harvest Size") +
  theme_classic() +
  btheme_paper

ggsave("slapdash_paper.png",
       width = 5, 
       height = 3,
       units = c("in"),
       dpi = 300, 
       device = "png", 
       limitsize = FALSE, 
       bg = "transparent")

```

```{r run, eval = FALSE, include = FALSE}

# Run the dynamic harvest demo from parameters.
output = aq(par11)

tibble_rc = output %>% 
  select(t, Revenue = r, Cost = c) %>%
  melt(id = 1) %>% 
  #mutate(Group = rep(c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3), 2)) %>% 
  rename(t = t, var = variable, val = value) %>% 
  mutate(val = val * 0.000001) %>% 
  mutate(group = c(rep(1, 4), rep(2, 4), rep(3, 2), rep(4, 4), rep(5, 4), rep(6, 2)))

tibble_rc$val[1] = NA
tibble_rc$val[5] = NA
tibble_rc$val[9] = NA

# Plot cumulative revenues and costs through harvest cycles.

## Presentation Graph
aq11_present = ggplot(tibble_rc, aes(t, val, color = var, group = group)) +
      geom_segment(aes(x = 4, xend = 4, y = 0, yend = Inf), linetype = "dashed") +
      geom_segment(aes(x = 8, xend = 8, y = 0, yend = Inf), linetype = "dashed") +
      geom_line(size = 3) +
      annotate("text", x = 5.35, y = 16.5, label = "800kg Dry Buche", size = 8, family = "Century Gothic") +
      annotate("text", x = 8.55, y = 16.5, label = "800kg", size = 8, family = "Century Gothic") +
      annotate("text", x = 10, y = 2.5, label = "C", size = 9, family = "Century Gothic") +
      annotate("text", x = 10, y = 10.5, label = "R", size = 9, family = "Century Gothic") +
      labs(x = "Years", y = "Millions USD", color = "") +
      scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(1, 2, 4, 8, 10)) +
      scale_y_continuous(expand = c(0, 0), limits = c(0, 17.000000), labels = scales::comma) +
      #ggtitle("Costs and Revenues for One Cage - Trimming and Harvest") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      theme_classic() +
      btheme_present +
      theme(legend.position = "none")

#widescreen
ggsave("faust_present.png", 
       width = 720, 
       height = 490,  
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

## Paper Graph

aq11_paper = ggplot(tibble_rc, aes(t, val, color = var, group = group)) +
      geom_segment(aes(x = 4, xend = 4, y = 0, yend = Inf), linetype = "dashed") +
      geom_segment(aes(x = 8, xend = 8, y = 0, yend = Inf), linetype = "dashed") +
      geom_line(size = 2) +
      annotate("text", x = 5.35, y = 16.5, label = "800kg Dry Buche", size = 3, family = "Century Gothic") +
      annotate("text", x = 8.55, y = 16.5, label = "800kg", size = 3, family = "Century Gothic") +
      annotate("text", x = 10, y = 2.5, label = "C", size = 4, family = "Century Gothic") +
      annotate("text", x = 10, y = 10.5, label = "R", size = 4, family = "Century Gothic") +
      labs(x = "Years", y = "Millions USD", color = "") +
      scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(1, 2, 4, 8, 10)) +
      scale_y_continuous(expand = c(0, 0), limits = c(0, 17.000000), labels = scales::comma) +
      #ggtitle("Costs and Revenues for One Cage - Trimming and Harvest") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      theme_classic() +
      btheme_paper +
      theme(legend.position = "none")

ggsave("faust_paper.png",
       width = 5, 
       height = 3,
       units = c("in"),
       dpi = 300, 
       device = "png", 
       limitsize = FALSE, 
       bg = "transparent")

```

```{r garrettfunkygraphtime, eval = FALSE, include = FALSE}

library(readr)
meatrev <- read_csv("~/GitHub/tma/meatrev.csv")

## Presentation graph

meatrev_present = ggplot(meatrev, aes(x = t))+
  geom_line(aes(y = tr), colour="#F4B183", size = 3) +
  geom_line(aes(y = c), colour="#1F4E79", size = 3) +
  geom_segment(aes(x = 2, xend = 2, y = 0, yend = Inf), linetype = "dashed") +
  labs(x = "Years", y = "Millions USD", color = "") +
  scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(2, 4, 6, 8, 10)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 3), labels = scales::comma) +
  theme(legend.position = "none") +
  btheme_present


ggsave("meatrev_present.png", 
       width = 720, 
       height = 490,  
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

## Paper Graph

meatrev_paper = ggplot(meatrev, aes(x = t))+
  geom_line(aes(y = tr), colour="#F4B183", size = 2) +
  geom_line(aes(y = c), colour="#1F4E79", size = 2) +
  geom_segment(aes(x = 2, xend = 2, y = 0, yend = Inf), linetype = "dashed") +
  labs(x = "Years", y = "Millions USD", color = "") +
  scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(2, 4, 6, 8, 10)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 3), labels = scales::comma) +
  theme(legend.position = "none") +
  btheme_paper

ggsave("meatrev_paper.png",
       width = 5, 
       height = 3,
       units = c("in"),
       dpi = 300, 
       device = "png", 
       limitsize = FALSE, 
       bg = "transparent")


```

