---
title: "Aquaculture Model"
date: '`r Sys.Date()`'
output: html_document
---

```{r script, include = FALSE}

knitr::read_chunk('setup.R')

```

```{r packages_list, include = FALSE, message = FALSE, error = FALSE, warning = FALSE}

```

```{r packages_inst, eval = FALSE, include = FALSE, message = FALSE, error = FALSE, warning = FALSE}

```

```{r packages_upda, eval = FALSE, include = FALSE, message = FALSE, error = FALSE, warning = FALSE}

```

```{r packages_libr, include = FALSE, message = FALSE, error = FALSE, warning = FALSE}

```

```{r fonts, include = FALSE, message = FALSE, error = FALSE, warning = FALSE}

```

```{r theme, include = FALSE, message = FALSE, error = FALSE, warning = FALSE}

```

```{r pkg_ins, echo = TRUE, warning = FALSE, message = FALSE}

rm(list=ls())

# Check out knitr for knitr::read_chunk.
library(knitr)

# Name packages.
pkg <- c("readr",
         "knitr",
         "tidyverse",
         "gapminder",
         "sandwich",
         "broom",
         "stargazer",
         "cowplot",
         "kableExtra",
         "reshape2",
         "devtools")

# Install packages.
#install.packages(pkg, verbose = FALSE, quiet = TRUE)
#devtools::install_github("AckerDWM/gg3D")
  
# Update packages.
#update.packages(pkg, verbose = FALSE, quiet = TRUE)

# Check out packages.
lapply(pkg, library, character.only = TRUE)

#library(gg3D)

```
```{r btheme}

btheme =
  theme(plot.title = element_text(hjust = 0.5, size = 32, family = "Century Gothic", face = "bold"), 
        rect = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent", color = NA),
        legend.position = "right",
        legend.background = element_rect(fill = "transparent"),
        legend.box.background = element_rect(fill = "transparent"),
        legend.key = element_rect(fill="transparent", colour=NA),
        legend.text = element_text(size = 16, family = "Century Gothic"),
        legend.title = element_text(size = 18, family = "Century Gothic"),
        panel.background = element_rect(fill = "transparent"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(size = 18, family = "Century Gothic"),
        axis.title.x = element_text(size = 24, family = "Century Gothic", face = "bold"),
        axis.text.y = element_text(size = 18, family = "Century Gothic"),
        axis.title.y = element_text(size = 24, family = "Century Gothic", face = "bold"))

```



#####Objective: Step through optimal rotations for a generic totoaba farm.

#####Age to Length

$L(t) = L_\infty ( 1 - e^{ - K ( t - t_0 )})$

Variable   | Definition                   | Value
---------- | ---------------------------  | --------------
*L*        | Length (Centimeters)         | 
$L_\infty$ | Maximum Length (Centimeters) | 180.000000
*K*        | Catabolic Constant (?!)      | 000.289291
*t*        | Age (Years)                  | 
$t_0$      | Age, *L* = 0                 | 000.000000

```{r al_function}

# Von Bertalanffy function.
fn_vb = function(linf, k, t, t_0){l = linf * ( 1 - exp( - k * ( t - t_0)))
                                  return(l)}

# Set parameter values for future reference.
vb_linf = 200 # From 180 to 200.
vb_k    = 0.155#0.22856
vb_t0   = -0.65

# Parameterization demo.
#a = seq(1, 25)
#l = fn_vb(vb_linf, vb_k, a, vb_t0)

#plot(a, l)

# Better graph for Goto.
#ggvb =
#ggplot() +
#  geom_path(aes(a, l), colour = "firebrick") +
#  labs(x = "Age (Years)", y = "Length (Centimeters)") +
#  scale_y_continuous(expand = c(0, 0)) +
#  ggtitle("Estimated Length-at-Age Function") +
#  theme(axis.text.x = element_text(size = 8),
#        axis.text.y = element_text(size = 8),
#        legend.text = element_text(size = 8),
#        axis.title.x = element_text(size = 9),
#        axis.title.y = element_text(size = 9),
#        legend.title = element_text(size = 9),
#        plot.title = element_text(size = 9)) +
#  theme_classic()

#ggsave("ggvb.png", ggvb, width = 5.5, height = 3, dpi = 300)

```

#####Age to Mortality

Cygnus Ocean Farms, SA de CV report mortality by month for two years.
 
```{r am_data}

a_months = seq(1, 24)
m_months = c(rep(5.00, 2), rep(2.40, 2), rep(1.60, 2), rep(1.15, 2), rep(1.00, 3), rep(0.80, 3), 0.50, rep(0.40, 6), 0.30, rep(0.20, 2))

dat_m = tibble(a_months, m_months)

#plot(dat_m$a_months, dat_m$m_months)

```
 
Supposing a mortality trend $m = \beta_1 * e^{\beta_2a}$, R function nls in package Stats 3.4.2 returns:
 
```{r am_results, echo = FALSE}

# Specification for nonlinear regression:
am_reg = nls(m_months ~ b1 * exp(b2 * a_months), dat_m, start = list(b1 = 8.00, b2 = - 1.00))

# Clean up output:
am_reg_tidy = tidy(am_reg, conf.int = TRUE, conf.level = 0.95)
dat_m_est = augment(am_reg)

#kable(am_reg_tidy)

#ggplot(dat_m_est) +
#  geom_point(aes(a_months, m_months)) +
#  geom_path(aes(a_months, .fitted))

# Better graph for Goto.
#ggam =
#ggplot(dat_m_est) +
#  geom_point(aes(a_months, m_months), colour = "gray50") +
#  geom_segment(aes(x = a_months, y = m_months, xend = a_months, yend = .fitted), colour = "gray50") +
#  geom_point(aes(a_months, .fitted), colour = "firebrick") +
#  labs(x = "Age (Months)", y = "Cohort Mortality (%)") +
#  scale_y_continuous(expand = c(0, 0)) +
#  ggtitle("Estimated Mortality-at-Age Function") +
#  theme(axis.text.x = element_text(size = 8),
#        axis.text.y = element_text(size = 8),
#        legend.text = element_text(size = 8),
#        axis.title.x = element_text(size = 9),
#        axis.title.y = element_text(size = 9),
#        legend.title = element_text(size = 9),
#        plot.title = element_text(size = 9)) +
#  theme_classic()

#ggsave("ggam.png", ggam, width = 5.5, height = 3, dpi = 300)

```

 Those results plug into a mortality-at-age function:


Variable   | Definition                  | Value
---------- | --------------------------- | -----------
*m*        | Cohort Mortality (%)        |
*a*        | Age (Months)                |
$\beta_1$  | Parameter                   | `r am_reg_tidy$estimate[1]`
$\beta_2$  | Parameter                   | `r am_reg_tidy$estimate[2]`

~~To keep a realistic non-zero mortality-at-age estimate, we add a proportional mortality of 0.01 to each month of age.~~

For convenience below, the indefinite integral of mortality-at-age, i.e. cumulative mortality, is also defined as:
$M = \frac{\beta_1 * e^{\beta_2a}}{\beta_2}$

```{r am_function}

# Note conversion from months to years for ease of use later.

# Set marginal mortality.
fn_am_marg = function(a, b1, b2){m = b1 * exp(b2 * a * 12) + 1} #Assumed that mortality keeps at 1% forever

# Cumulative mortality doesn't work the way you think it does - reconsider and work out a new functional form.

# Set parameters for reference.
am_b1 = am_reg_tidy$estimate[1]
am_b2 = am_reg_tidy$estimate[2]

```

#####Weight-Length Conversion

$W = aL^b$

Variable   | Definition
---------- | ---------------------------
*W*        | Weight (Kilograms)
*L*        | Length (Centimeters)
*a*        | Parameter
*b*        | Parameter

```{r lw_function}

# Generic length-to-weight conversion. 
fn_lw = function(a, l, b){w = a * l ^ b
                          return(w)}

# Set parameter values for future reference.
wl_a = 0.000004128
wl_b = 3.24674

# Parameterization demo.
l = seq(0, 200, by = 10)
w = fn_lw(wl_a, l, wl_b)
plot(l, w)

# Better graph for Goto.
gglw =
ggplot() +
  geom_path(aes(l, w), colour = "firebrick") +
    labs(x = "Length (Centimeters)", y = "Weight (Kilograms)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Weight-at-Length Function") +
  theme(axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        legend.title = element_text(size = 9),
        plot.title = element_text(size = 9)) +
  theme_classic()
#gglw
#ggsave("gglw.png", gglw, width = 5.5, height = 3, dpi = 300)

```

#####Age to Count

After mortality, any biomass in excess of optimal stocking density is harvested. Optimal density is 160,000 kilograms per cage at and after first salable size. First salable size is 2 kilograms.

$T = n_t^* - n_{t-1}^* * m_{t-1}$

```{r ac_calc}

# Density is highest possible kilograms per cubic meter without density-dependence slowing growth.
density = 160000 # Goto or Miguel - is this from Felipe?

# Size is first saleable size in kilograms.
size = 3 # Communications with EOF (2018).

a = seq(1, 25)
w = fn_lw(wl_a, fn_vb(vb_linf, vb_k, a, vb_t0), wl_b)
fn_ns = function(density, w){ns = density / w} # Note lag on age to get last year's mortality.

# Cohort count at first saleable size is the ratio of density in kgm^-3 to size in kg.
nsale = density / size

# Initial cohort count is density at first saleable size, plus cumulative mortality at first saleable age.
# Casually, nstart = nsale + mort(a(l(wsale))).
# Cumulative mortality to first saleable age:
a_sale = (vb_t0 - 1 / vb_k * (log(1 - ((size / wl_a) ^ (1 / wl_b))/vb_linf))) # Inverse Von Bertalanffy.
nstart = nsale * (100 / (100 - fn_am_marg(a_sale, am_b1, am_b2))) * (100 / (100 - fn_am_marg(1, am_b1, am_b2))) * (100 / (100 - fn_am_marg(1, am_b1, am_b2)))
#nstart = nsale / (1 - m_sale * 0.01)

# Trimming is individuals harvested each year to keep stocking density below maximum after mortality.
# Here, trimming is cumulative. The iterative implementation is more useful.
#fn_nm = function(nstart, a, am_b1, am_b2){nm = nstart * (1 - 0.01 * fn_am_cumu(a, am_b1, am_b2))}
#fn_nt = function(density, w, a, am_b1, am_b2, nstart){nt = ifelse(fn_nm(nstart, a, am_b1, am_b2) - fn_ns(density, w) > 0, 
#                                                                  fn_nm(nstart, a, am_b1, am_b2) - fn_ns(density, w), 
#                                                                  0)}

#ntrim = fn_nt(density, w, a, am_b1, am_b2, nstart)

#plot(a, ntrim)

```

#####Weight-Maw Conversion

For a stock of $n_{a, t}$ totoaba cultivated for *a* years in year *t* to weight $w_{a, t}$ for a total round weight of $x_{a, t}$, maw yield $y_{a, t}$ depends on wet maw yield ratio $c^{maw}_{a, t}$ and dry yield ratio $k$.

$y^{maw}_{a, t} = w_{a, t}n_{a, t}c^{maw}_{a, t}k^{maw}_{dry}$

Variable   | Definition
---------- | --------------------------------
$y^{maw}$  | Cohort Dry Maw Yield (Kilograms)
*w*        | Individual Round Weight (Kilograms)
*n*        | Cohort Count
$c^{maw}$  | Yield of maw from round weight.
$k^{maw}$  | Yield of dry maw from wet maw.

```{r wm_function}

fn_wm = function(w, n, c, k){ymaw = w * n * c * k}

# Parameters from cultivated sample (UABC & PhD) and from inapesca wild sample:
wm_c = 0.0161
wm_k = 0.31

```

#####Maw-Price Conversion

Grams! It's all grams! Remember to convert.

```{r mp_function}

#fn_mp = function(w, b0, bw, bq, q, bc, c){pmaw = b0 + w ^ bw + bq * q + bc * c}
fn_mp = function(w, b0, b1, b2, q){pmaw = (q * b1 + (w * 1000) ^ b2 + b0) * 1000}

# Parameters from regression.
mp_b0 = 82.99177
mp_b1 = -5.28312
mp_b2 = 0.52540
mp_q = 10 # Note that 14 fills in for a reasonable quantity at market from poaching.
#mp_q has to be a vector
```

#####Maw-Revenue Conversion

For a dry maw yield $y^{maw}$ in kilograms, revenue depends on price.

$R^{maw}_{a, t} = x_{a, t}/n_{a, t} * (\beta_0 + \beta_{g}(x_{a, t}/n_{a, t}))$

```{r mr_function}

fn_mr = function(ymaw, pmaw){rmaw = ymaw * pmaw}

```

#####Round-Revenue Conversion

For a stock of *n* totoaba cultivated for *a* years in year *t* for an individual round weight of $w_{a, t}$, revenue depends on price.

$R^{round}_{a, t} = w_{a, t} * n_{a, t} * p^{round}$

```{r wr_function}

fn_fr = function(w, n, pround){rround = w * n * pround}

# Parameter from market research:
pround = 6.50 # Source? Miguel?

```

#####Feed Conversion Function

Note placeholder assumption of constant marginal feed requirement.

~~Thanks, Goto!~~

```{r fcr_data, eval = FALSE}

dat_fcr = read.csv("fcr.csv")

# Convert values from grams to kilograms for later.
dat_fcr$weight = dat_fcr$weight / 1000
dat_fcr$feed = dat_fcr$feed / 1000

```

~~For reasons, we assume functional form $F = \beta_1 * w^{\beta_2}$~~

```{r fcr_results, eval = FALSE}

# Specification for nonlinear regression:
fcr_reg = nls(feed ~ b1 * weight ^ b2, dat_fcr, start = list(b1 = 0.0268, b2 = - 1.855))

# Clean up output:
fcr_reg_tidy = tidy(fcr_reg, conf.int = TRUE, conf.level = 0.95)
dat_fcr_est = augment(fcr_reg)

kable(fcr_reg_tidy)

ggplot(dat_fcr_est) +
  geom_point(aes(weight, feed)) +
  geom_point(aes(weight, .fitted, colour = "red"))

# Better graph for Goto.
ggfcr =
ggplot(dat_fcr_est) +
  geom_point(aes(weight, feed), colour = "gray50") +
  geom_segment(aes(x = weight, y = feed, xend = weight, yend = .fitted), colour = "gray50") +
  geom_point(aes(weight, .fitted), colour = "firebrick") +
  labs(x = "Weight (Kilograms)", y = "Feed Requirement (Kilograms)") +
  scale_y_continuous(expand = c(0, 0)) +
  ggtitle("Estimated Feed-at-Weight Function") +
  theme(axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        legend.text = element_text(size = 8),
        axis.title.x = element_text(size = 9),
        axis.title.y = element_text(size = 9),
        legend.title = element_text(size = 9),
        plot.title = element_text(size = 9)) +
  theme_classic()

#ggsave("ggfcr.png", ggfcr, width = 5.5, height = 3, dpi = 300)

```

Those results plug into a feed-at-weight function:

Variable   | Definition                  | Value
---------- | --------------------------- | -----------
*w*        | Weight (Kilograms)          |
*f*        | Cumulative Feed (Kilograms) |
$\beta_1$  | Parameter                   | `r fcr_reg_tidy$estimate[1]`
$\beta_2$  | Parameter                   | `r fcr_reg_tidy$estimate[2]`

For convenience below, the derivative of feed-at-weight, i.e. instantaneous feed requirement, is also defined as:
$f = \beta_1 \beta_2 w^{\beta_{1}-1}$

```{r fcr_function}

# Regression to constant marginal feed requirement.

# Set cumulative feed requirement.
fn_f_cumu = function(w, b1, b2){F = b1 * w ^ b2}

# Set marginal feed requirement.
#fn_f_marg = function(w, b1, b2){f = b1 * b2 * w ^ (b2 - 1)}
fn_f_marg = function(w, b1, b2){f = b1 * b2 * w}

# Set parameters for reference.
f_b1 = 0.01 #fcr_reg_tidy$estimate[1]
f_b2 = 1.00 #fcr_reg_tidy$estimate[2]

```

#####No-Harvest Cost

Thanks, Goto!

```{r c_stock}

# Marginal cohort cost.
fn_ch0 = function(w, b1, b2, cf, n, o){ch0 = n * cf * fn_f_marg(w, b1, b2) * 365 + o} # FCR is daily, so multiply by days.

# Parameters.
#  Cost, USD/kg.
ch0_cf = 2
# Overhead, from eight cages for ten years down to one cage for one year.
o = 170000

```


#####Harvest Cost

```{r c_restock}

ch1 = nstart * 2 + o # Fry Cost (CREMES).

```

##### Parameter Set-Up

```{r pars}

# Define parameters for each low-level function in a high-level function of multiple harvests over time.
var = c("start", 
        "end", 
        "linf", 
        "k",
        "t0", 
        "a", 
        "b", 
        "n0", 
        "yround", 
        "ywet", 
        "b0", 
        "b1",
        "b2",
        "q",
        "pround", 
        #"c_coeff",
        #"c_exp",
        "f_b1", 
        "f_b2", 
        "ch0_cf", 
        "o",
        "c_restock",
        "disc",
        "density",
        "am_b1",
        "am_b2",
        "nstart",
        "harvest",
        "maw")

par00 = c(1, 
          10, 
          vb_linf, 
          vb_k, 
          vb_t0,
          wl_a,
          wl_b,
          nstart,
          wm_c,
          wm_k,
          mp_b0,
          mp_b1,
          mp_b2,
          mp_q,
          pround,
          f_b1, 
          f_b2, 
          ch0_cf, 
          o,
          ch1,
          0.84,
          density,
          am_b1,
          am_b2,
          nstart,
          0,
          0)

par01 = par00
par01[27] = 1

par10 = par00
par10[26] = 1

par11 = par00
par11[27] = 1
par11[26] = 1

fun = c(rep("All", 2), 
        rep("Age-Length", 3),
        rep("Length-Weight", 2),
        rep("Weight-Maw", 3),
        rep("Maw-Price", 4),
        "Weight-Revenue (Round)",
        rep("No-Harvest Cost", 4),
        "Harvest Cost",
        "Discount Factor",
        rep("Density-Optimal Stocking", 4),
        "Harvest Switch",
        "Maw Switch")

num = seq(1, length(var))

tab = data.frame(num, fun, var, par00, par10, par01, par11)

# Save parameters to working directory.
#kable(tab, digits = 2) %>%
#  kable_styling() %>%
#  save_kable(file = "partab.html", self_contained = T)

```

##### Single-Run Function

```{r fun}
# Define a function for dynamic harvests over time.
aq = function(par){t = as.numeric(vector(length = par[2]))  # First, initialize blank vectors for each variable.
                   a0 = as.numeric(vector(length = par[2]))
                   a1 = as.numeric(vector(length = par[2]))

                   h = as.numeric(vector(length = par[2]))
                   hinv = as.numeric(vector(length = par[2]))
                   
                   l0 = as.numeric(vector(length = par[2]))
                   w0 = as.numeric(vector(length = par[2]))
                   nm0 = as.numeric(vector(length = par[2]))
                   ns0 = as.numeric(vector(length = par[2]))
                   nt0 = as.numeric(vector(length = par[2]))
                   n0 = as.numeric(vector(length = par[2]))
                   rt0 = as.numeric(vector(length = par[2]))
                   y0 = as.numeric(vector(length = par[2]))
                   p0 = as.numeric(vector(length = par[2]))
                   rmaw0 = as.numeric(vector(length = par[2]))
                   rround0 = as.numeric(vector(length = par[2]))
                   r0 = as.numeric(vector(length = par[2]))
                   c0 = as.numeric(vector(length = par[2]))
                   
                   l1 = as.numeric(vector(length = par[2]))
                   w1 = as.numeric(vector(length = par[2]))
                   nm1 = as.numeric(vector(length = par[2]))
                   ns1 = as.numeric(vector(length = par[2]))
                   nt1 = as.numeric(vector(length = par[2]))
                   n1 = as.numeric(vector(length = par[2]))
                   rt1 = as.numeric(vector(length = par[2]))
                   y1 = as.numeric(vector(length = par[2]))
                   p1 = as.numeric(vector(length = par[2]))
                   rmaw1 = as.numeric(vector(length = par[2]))
                   rround1 = as.numeric(vector(length = par[2]))
                   r1 = as.numeric(vector(length = par[2]))
                   c1 = as.numeric(vector(length = par[2]))
                   
                   r = as.numeric(vector(length = par[2]))
                   c = as.numeric(vector(length = par[2]))
                  
                   t[1] = par[1] # Plug a starting value into each vector's first cell.
                   a0[1] = t[1]
                   a1[1] = a0[1] + 1
                   
                   h[1] = 0
                   hinv[1] = 1
                   
                   l0[1] = fn_vb(par[3], par[4], t[1], par[5])
                   w0[1] = fn_lw(par[6], l0[1], par[7])
                   nm0[1] = nstart * (0.01 * fn_am_marg(a0[1], par[23], par[24]))
                   ns0[1] = nstart * (1 - 0.01 * fn_am_marg(a0[1], par[23], par[24])) # Note leading mortality.
                   nt0[1] = ifelse(ns0[1] - fn_ns(par[22], w0[1]) > 0, ns0[1] - fn_ns(par[22], w0[1]), 0)
                   n0[1] = nstart - nm0[1] - nt0[1]
                   rt0[1] = fn_fr(w0[1], nt0[1], par[15])
                   y0[1] = fn_wm(w0[1], n0[1], par[9], par[10])
                   p0[1] = fn_mp(w0[1], par[11], par[12], par[13], par[14] + y0[1] / 1000) * 0.10 # Note price transformation.
                   rmaw0[1] = y0[1] * p0[1]
                   rround0[1] = w0[1] * par[15]
                   r0[1] = (rmaw0[1] + rround0[1])
                   c0[1] = fn_ch0(w0[1], par[16], par[17], par[18], par[8], par[19])

                   l1[1] = fn_vb(par[3], par[4], 2, par[5])
                   w1[1] = fn_lw(par[6], l1[1], par[7])
                   # Since this implementation of mortality/survival and trimming require iteration to work, the corresponding lead variables are spaghetti.
                   nm1[1] = (nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24])) - 
                               ifelse(nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24]) - fn_ns(par[22], w1[1])) > 0, 
                                      nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24]) - fn_ns(par[22], w1[1])), 
                                      0)) * (0.01 * fn_am_marg(a1[1], par[23], par[24]))
                   ns1[1] = (nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24])) - 
                               ifelse(nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24]) - fn_ns(par[22], w1[1])) > 0, 
                                      nstart * (1 - 0.01 * fn_am_marg(a1[1] - 1, par[23], par[24]) - fn_ns(par[22], w1[1])), 
                                      0)) * (1 - 0.01 * fn_am_marg(a1[1], par[23], par[24])) # Note leading mortality
                   nt1[1] = ifelse(ns1[1] - fn_ns(par[22], w1[1]), ns1[1] - fn_ns(par[22], w1[1]), 0)
                   n1[1] = fn_ns(density, w1[1])
                   rt1[1] = fn_fr(w1[1], nt1[1], par[15])
                   y1[1] = fn_wm(w1[1], n1[1], par[9], par[10])
                   p1[1] = fn_mp(w1[1], par[11], par[12], par[13], par[14] + y1[1] / 1000) * 0.10 # Note price transformation.
                   rmaw1[1] = y1[1] * p1[1]
                   rround1[1] = w1[1] * par[15]
                   r1[1] = (rmaw1[1] + rround1[1])
                   c1[1] = fn_ch0(w1[1], par[16], par[17], par[18], par[8], par[19])
                   
                   r[1] = r0[1]
                   c[1] = c0[1]
                  
                   # With vectors to fill and initial values to loop from, loop through periods of interest. i is years.                   
                   for(i in 2:par[2]){
                     t[i] = t[i - 1] + 1
                     
                     a0[i] = a0[i - 1] * hinv[i - 1] + 1
                     a1[i] = a0[i] + 1
                     
                     l0[i] = fn_vb(par[3], par[4], a0[i], par[5])
                     w0[i] = fn_lw(par[6], l0[i], par[7])
                     nm0[i] = (nstart * h[i - 1] + n0[i - 1] * hinv[i - 1]) * (0.01 * fn_am_marg(a0[i], par[23], par[24])) # Note leading mortality.
                     ns0[i] = (nstart * h[i - 1] + n0[i - 1] * hinv[i - 1]) * (1 - 0.01 * fn_am_marg(a0[i], par[23], par[24])) # Note leading mortality.
                     nt0[i] = ifelse(ns0[i] - fn_ns(par[22], w0[i]) > 0, ns0[i] - fn_ns(par[22], w0[i]), 0)
                     n0[i] = (nstart * h[i - 1] + n0[i - 1] * hinv[i - 1]) - nm0[i] - nt0[i]
                     rt0[i] = fn_fr(w0[i], nt0[i], par[15])
                     y0[i] = fn_wm(w0[i], n0[i], par[9], par[10])
                     p0[i] = fn_mp(w0[i], par[11], par[12], par[13], par[14] + y0[i - 1] / 1000) * 0.10 # Note price transformation.
                     rmaw0[i] = y0[i] * p0[i]
                     rround0[i] = fn_fr(w0[i], n0[i], par[15])
                     r0[i] = par[27] * rmaw0[i] + rround0[i]
                     c0[i] = fn_ch0(w0[i], par[16], par[17], par[18], n0[i], par[19])
                     
                     l1[i] = fn_vb(par[3], par[4], a1[i], par[5])
                     w1[i] = fn_lw(par[6], l1[i], par[7])
                     nm1[i] = (nstart * h[i - 1] + n1[i - 1]) * hinv[i - 1] * (0.01 * fn_am_marg(a1[i], par[23], par[24])) # Note leading mortality.
                     ns1[i] = (nstart * h[i - 1] + n1[i - 1]) * hinv[i - 1] * (1 - 0.01 * fn_am_marg(a1[i], par[23], par[24])) # Note leading mortality.
                     nt1[i] = ifelse(ns1[i] - fn_ns(par[22], w1[i]) > 0, ns1[i] - fn_ns(par[22], w1[i]), 0)
                     n1[i] = (nstart * h[i - 1] + n1[i - 1] * hinv[i - 1]) - nm1[i] - nt1[i]
                     rt1[i] = fn_fr(w1[i], nt1[i], par[15])
                     y1[i] = fn_wm(w1[i], n1[i], par[9], par[10])
                     p1[i] = fn_mp(w1[i], par[11], par[12], par[13], par[14] + y1[i - 1] / 1000) * 0.10 # Note price transformation.
                     rmaw1[i] = y1[i] * p1[i]
                     rround1[i] = fn_fr(w1[i], n1[i], par[15])
                     r1[i] = rmaw1[i] + rround1[i]
                     c1[i] = fn_ch0(w1[i], par[16], par[17], par[18], n1[i], par[19])
                     
                     # Mind wrapper for hard-coding lower bound age at harvest.
                     h[i] = par[26] * ifelse(a0[i] > 0, ifelse((r0[i] - par[20]) > (par[21] * (r1[i] - c0[i] + rt0[i])), 1, 0), 0) # Think hard about lags here.
                     hinv[i] = (h[i] - 1) ^ 2
                     
                     r[i] = (r0[i] + rt0[i] * hinv[i])
                     c[i] = c0[i] * hinv[i] + par[20] * h[i]
                     
                     }
                    
                    output = tibble(t, c, r, p0, w0, n0, h, r0, r1, rround0, rt1, )

                  return(output)}

output2 = aq(par10)

write.csv(output2, "output2.csv")


```

##### Run 11 + Profit

```{r run11}

# Run the dynamic harvest demo from parameters.
output = aq(par11)

tibble_rc = output %>% 
  select(-h) %>% 
  melt(id = 1) %>% 
  rename(t = t, var = variable, val = value)

# Plot cumulative revenues and costs through harvest cycles.
h = ggplot(tibble_rc, aes(t, val, color = var)) +
      geom_path() +
      labs(x = "Years", y = "USD2018") +
      #scale_x_continuous(expand = c(0, 0), limits = c(1, 25)) +
      #scale_y_continuous(expand = c(0, 0), limits = c(0, 300000000), labels = scales::comma) +
      #ggtitle("Costs and Revenues for One Cage - Trimming and Harvest") +
      theme_classic() +
      theme(axis.text.x = element_text(size = 8),
          axis.text.y = element_text(size = 8),
          #legend.text = element_text(size = 8),
          axis.title.x = element_text(size = 9),
          axis.title.y = element_text(size = 9),
          #legend.title = element_text(size = 9),
          plot.title = element_text(size = 9))#,
          #legend.position = "none")

# Save harvest plot to working directory.
#ggsave("h1plot.png", plot = h, dpi = 300, width = 6.5, height = 4.5)

# Save output to working directory.
#kable(output) %>%
#  kable_styling() %>%
#  save_kable(file = "htab.html", self_contained = T)

# Calculate and plot profit.
tbl_pi = output %>% 
  mutate(c1 = lead(c)) %>% 
  filter(!is.na(c1)) %>% 
  mutate(mc = ifelse(c1 - c > 0, c1 - c, 0)) %>% 
  mutate(rsale = r * h) %>% 
  mutate(pi = rsale - mc)

#plot(tbl_pi$t, tbl_pi$pi)

# Calculate and plot cumulative profit.
pi_sum = as.numeric(vector(length = par00[2] - 1))
pi_sum[1] = 0

for(i in 2:9){pi_sum[i] = tbl_pi$r[i] * tbl_pi$h[i] - tbl_pi$mc[i] + pi_sum[i - 1]} # par[2] for length

tbl_pi = cbind(tbl_pi, pi_sum)

# Add a column for color by vertical position.
tbl_pi = mutate(tbl_pi, color = ifelse(pi_sum > 0, 1, 0))

# Basic plot.  
#plot(tbl_pi$t, tbl_pi$pi_sum)

# Better plots.
pimargplot =
ggplot(tbl_pi, aes(t, pi)) +
  geom_path() +
  labs(x = "Years", y = "USD2018") +
      #scale_x_continuous(expand = c(0, 0), limits = c(1, 24)) +
      #scale_y_continuous(expand = c(0, 0), limits = c(-200000000, 600000000), labels = scales::comma) +
      #ggtitle("Annual Profit for One Cage - Harvest and Trimming, No Trimming Revenue") +
      theme_classic() +
      theme(axis.text.x = element_text(size = 8),
          axis.text.y = element_text(size = 8),
          #legend.text = element_text(size = 8),
          axis.title.x = element_text(size = 9),
          axis.title.y = element_text(size = 9),
          #legend.title = element_text(size = 9),
          plot.title = element_text(size = 9),
          legend.position = "none")

picumuplot =
ggplot(tbl_pi, aes(t, pi_sum)) +
  geom_path() +
  labs(x = "Years", y = "USD2018") +
      #scale_x_continuous(expand = c(0, 0), limits = c(1, 24)) +
      #scale_y_continuous(expand = c(0, 0), limits = c(-200000000, 600000000), labels = scales::comma) +
      #ggtitle("Cumulative Profit for One Cage - Harvest and Trimming, No Trimming Revenue") +
      theme_classic() +
      theme(axis.text.x = element_text(size = 8),
          axis.text.y = element_text(size = 8),
          #legend.text = element_text(size = 8),
          axis.title.x = element_text(size = 9),
          axis.title.y = element_text(size = 9),
          #legend.title = element_text(size = 9),
          plot.title = element_text(size = 9),
          legend.position = "none")

# Save!

#ggsave("pimplot.png", plot = pimargplot, dpi = 300, width = 6.5, height = 4.5)
#ggsave("picplot.png", plot = picumuplot, dpi = 300, width = 6.5, height = 4.5)

```

##### Presentation Figures

```{r run00_costs_presentation}

# Run the dynamic harvest demo from parameters.
output = aq(par00)

output = select(output, t, c)

# Reference .csv written from model output in console to save time.
#output = read.csv("cagecost_20190201.csv")

tibble_rc = output %>% 
  #select(-X) %>% 
  #select(-h, -p0) %>% 
  melt(id = 1) %>% 
  rename(t = t, var = variable, val = value) %>% 
  mutate(val = val * 0.000001)

# Plot cumulative revenues and costs through harvest cycles.
cost = ggplot(tibble_rc, aes(t, val)) +
      geom_line(size = 3, color = "#1F4E79") +
      annotate("text", x = 8.5, y = 1.15, label = "Costs", size = 9, family = "Century Gothic") +
      scale_x_continuous(limits = c(1, 10), breaks = c(1, 2, 10), expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 3.000000), labels = scales::comma, expand = c(0, 0)) +
      theme_classic() +
      #ggtitle("Costs for One Cage") +
      labs( x = "Years", y = "Millions USD") +
      btheme

ggsave("cagecost_20190201.png",
       width = 720, 
       height = 490, 
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

```

```{r growthrates}

fn_vb = function(linf, k, t, t_0){l = linf * ( 1 - exp( - k * ( t - t_0)))}

# Set parameter values for future reference.
vb_linf = 200 # From 180 to 200.
vb_k_slow = 0.155
vb_k_fast = 0.22856
vb_t0   = -0.65

fn_lw = function(a, l, b){w = a * l ^ b
                          return(w)}

# Set parameter values for future reference.
wl_a = 0.000004128
wl_b = 3.24674

# Run out vector of ages.
a = seq(0, 27)
w_slow = fn_lw(wl_a, fn_vb(vb_linf, vb_k_slow, a, vb_t0), wl_b)
w_fast = fn_lw(wl_a, fn_vb(vb_linf, vb_k_fast, a, vb_t0), wl_b)

weights = data.frame(a, w_slow, w_fast)

w_plot = ggplot(weights) +
      geom_line(aes(a, w_slow), size = 3, color = "#1F4E79") +
      geom_line(aes(a, w_fast), size = 3, color = "#F4B183") +
      annotate("text", x = 23, y = 105, label = "Wild", size = 9, family = "Century Gothic") +
      annotate("text", x = 23, y = 128, label = "Aquaculture", size = 9, family = "Century Gothic") +
      labs(x = "Years", y = "Kilograms") +
      scale_x_continuous(limits = c(0, 27), breaks = c(0, 10, 20, 27), expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 150), labels = scales::comma, expand = c(0, 0)) +
      theme_classic() +
      btheme

ggsave("weights_20190201.png",
       width = 720, 
       height = 490, 
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

write.csv(weights,"weights.csv")

```

```{r meatprofit}

# Run the dynamic harvest demo from parameters.
output = aq(par10)

tibble_rc = output %>% 
  select(t, Revenue = r, Cost = c) %>% 
  #select(-h, -p0) %>% 
  melt(id = 1) %>% 
  rename(t = t, var = variable, val = value) %>% 
  mutate(val = val * 0.000001)

tibble_rc$val[1] = NA
#tibble_rc$val[4:10] = tibble_rc$val[3]


# Plot cumulative revenues and costs through harvest cycles.
meat = ggplot(tibble_rc, aes(t, val, color = var)) +
      geom_segment(aes(x = 3, xend = 3, y = 0, yend = Inf), linetype = "dashed") +
      geom_path(size = 3) +
      annotate("text", x = 8.5, y = 1.15, label = "Costs", size = 9, family = "Century Gothic") +
      annotate("text", x = 9, y = 2.500000, label = "Revenues", size = 9, family = "Century Gothic") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      labs(x = "Years", y = " Millions USD", color = "") +
      scale_x_continuous(limits = c(1, 10), breaks = c(1, 2, 3, 10),expand = c(0, 0.125)) +
      scale_y_continuous(limits = c(0, 3.000000), labels = scales::comma, expand = c(0, 0)) +
      btheme +
      theme(legend.position = "none")

ggsave("meat_20190201.png", 
       width = 720, 
       height = 490, 
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")


```

```{r allprofit}

# Run the dynamic harvest demo from parameters.
output = aq(par01)

tibble_rc = output %>% 
  select(t, Revenue = r, Cost = c) %>% 
  #select(-h, -p0) %>% 
  melt(id = 1) %>% 
  rename(t = t, var = variable, val = value) %>% 
  mutate(val = val * 0.000001)

tibble_rc$val[1] = NA

# Plot cumulative revenues and costs through harvest cycles.
mbpi = ggplot(tibble_rc, aes(t, val, color = var)) +
      geom_path(size = 3) +
      annotate("text", x = 8.5, y = 3, label = "Costs", size = 9, family = "Century Gothic") +
      annotate("text", x = 9, y = 31, label = "Revenues", size = 9, family = "Century Gothic") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      labs(x = "Years", y = "Millions USD", color = "") +
      scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(1, 2, 10)) +
      scale_y_continuous(expand = c(0, 0), limits = c(0, 35)) +
      theme_classic() +
      btheme +
      theme(legend.position = "none")

ggsave("mbpi_20190201.png", 
       width = 720, 
       height = 490, 
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")


```

```{r slapdash}

q = seq(0, 20)
p = 83 - 5.28 * q + 39.48 ^ 0.525
phh = ifelse(q < 11, 83 - 5.28 * 10 + 750 ^ 0.525, 83 - 5.28 * q + 750 ^ 0.525)
phl = ifelse(q < 15, 83 - 5.28 * 15 + 750 ^ 0.525, 83 - 5.28 * q + 750 ^ 0.525)
pth = ifelse(q < 15, 83 - 5.28 * 15 + 750 ^ 0.525, 83 - 5.28 * q + 750 ^ 0.525)
ptl = rep(0, 21)

slapdat = data.frame(q, p, phh, phl, pth, ptl)

slapdash =
ggplot(data = slapdat) +
  geom_line(aes(q, p), color = "#1F4E79", size = 3) +
  labs(x = "Tonnes of Buche", y = "USD / Gram of Buche") +
  scale_x_continuous(expand = c(0, 0.125), breaks = c(0, 5, 10, 15, 17), limits = c(0, 17)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 90)) +
  #ggtitle("Demand for Dry Maw at First Harvest Size") +
  theme_classic() +
  btheme

#widescreen
ggsave("slapdash.png", 
       width = 720, 
       height = 490,   
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

```

```{r run}

# Run the dynamic harvest demo from parameters.
output = aq(par11)

tibble_rc = output %>% 
  select(t, Revenue = r, Cost = c) %>%
  melt(id = 1) %>% 
  #mutate(Group = rep(c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3), 2)) %>% 
  rename(t = t, var = variable, val = value) %>% 
  mutate(val = val * 0.000001) %>% 
  mutate(group = c(rep(1, 4), rep(2, 4), rep(3, 2), rep(4, 4), rep(5, 4), rep(6, 2)))

tibble_rc$val[1] = NA
tibble_rc$val[5] = NA
tibble_rc$val[9] = NA

# Plot cumulative revenues and costs through harvest cycles.
aq11 = ggplot(tibble_rc, aes(t, val, color = var, group = group)) +
      geom_segment(aes(x = 4, xend = 4, y = 0, yend = Inf), linetype = "dashed") +
      geom_segment(aes(x = 8, xend = 8, y = 0, yend = Inf), linetype = "dashed") +
      geom_line(size = 3) +
      annotate("text", x = 5.35, y = 16.5, label = "800kg Dry Buche", size = 8, family = "Century Gothic") +
      annotate("text", x = 8.55, y = 16.5, label = "800kg", size = 8, family = "Century Gothic") +
      annotate("text", x = 10, y = 2.5, label = "C", size = 9, family = "Century Gothic") +
      annotate("text", x = 10, y = 10.5, label = "R", size = 9, family = "Century Gothic") +
      labs(x = "Years", y = "Millions USD", color = "") +
      scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(1, 2, 4, 8, 10)) +
      scale_y_continuous(expand = c(0, 0), limits = c(0, 17.000000), labels = scales::comma) +
      #ggtitle("Costs and Revenues for One Cage - Trimming and Harvest") +
      scale_color_manual(values = c("#F4B183", "#1F4E79")) +
      theme_classic() +
      btheme +
      theme(legend.position = "none")

#widescreen
ggsave("faust.png", 
       width = 720, 
       height = 490,  
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")

```

```{r garrett's funky graph time}

library(readr)
meatrev <- read_csv("~/GitHub/tma/meatrev.csv")

ggplot(meatrev, aes(x = t))+
  geom_line(aes(y = tr), colour="#F4B183", size = 3) +
  geom_line(aes(y = c), colour="#1F4E79", size = 3) +
  geom_segment(aes(x = 2, xend = 2, y = 0, yend = Inf), linetype = "dashed") +
  labs(x = "Years", y = "Millions USD", color = "") +
  scale_x_continuous(expand = c(0, 0.125), limits = c(1, 10), breaks = c(2, 4, 6, 8, 10)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 3), labels = scales::comma) +
  theme(legend.position = "none") +
  btheme


#widescreen
ggsave("meatrev.png", 
       width = 720, 
       height = 490,  
       dpi = 300, 
       device = png, 
       limitsize = FALSE, 
       bg = "transparent")


```

