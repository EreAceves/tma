---
title: "Aquaculture Model"
date: "`r Sys.Date()`"
output: html_document
---

```{r pkg_ins, include = FALSE}

#rm(list=ls())

# Check out knitr for knitr::read_chunk.
library(knitr)

# Name packages.
pkg <- c("readr",
         "knitr",
         "tidyverse",
         "gapminder",
         "sandwich",
         "broom",
         "stargazer",
         "cowplot",
         "reshape2",
         "kableExtra")

# Install packages.
#install.packages(pkg, verbose = FALSE, quiet = TRUE)

  
# Update packages.
#update.packages(pkg, verbose = FALSE, quiet = TRUE)

# Check out packages.
lapply(pkg, library, character.only = TRUE)

```

#####Objective: Step through optimal harvest and planting decisions by a generic totoaba farm..

Toy Model:

Parameters for White seabass (Cynoscion nobiliis) from:
Thomas, J. C. (1968). Management of the white seabass (Cynoscion nobilis) in California waters. State of California. The Resources Agency. Department of Fish and Game.

#####Von Bertalanffy Growth Model

$L(t) = L_\infty ( 1 - e^{ - K ( t - t_0 )})$

Variable   | Definition
---------- | ---------------------------
*L*        | Length (Millimeters)
$L_\infty$ | Maximum Length (mm)
*K*        | Catabolic Constant (?!)
*t*        | Age (Years)
$t_0$      | Age, *L* = 0

```{r al_function}

# Von Bertalanffy function.
fn_vb = function(linf, k, t, t_0){l = linf * ( 1 - exp( - k * ( t - t_0)))
                                  return(l)}

# White seabass demo with age in years and length in millimeters.
v_vb_a_wsb = seq(0, 25)
v_vb_l_wsb = fn_vb(1465.3822, 0.1280, v_vb_a_wsb, -0.2805)
plot(v_vb_a_wsb, v_vb_l_wsb)


# Totoaba demo.
#v_vb_a_tma = seq(a0, amax)
#v_vb_l_tma = fn_vb(linf, k, v_vb_a_tma, t_0)
#plot(v_vb_a_tma, v_vb_l_tma)

```

#####Weight-Length Conversion

$W = aL^b$

Variable   | Definition
---------- | ---------------------------
*W*        | Weight (Grams)
*a*        | Length (Millimeters)
*L*        | Parameter
*b*        | Parameter

```{r lw_function}

# Generic length-to-weight conversion. 
fn_lw = function(a, l, b){w = a * l ^ b
                          return(w)}

# White seabass demo in mm:g.
v_lw_l_wsb = seq(0, 1500, by = 100)
v_lw_w_wsb = fn_lw(0.000015491, v_lw_l_wsb, 2.92167)
plot(v_lw_l_wsb, v_lw_w_wsb)

# Totoaba demo.
#v_lw_l_tma = seq(l0, linf, by = 100)
#v_lw_w_tma = fn_lw(a, v_lw_l_tma, b)
#plot(v_lw_l_tma, v_lw_w_tma)

```

#####Weight-Maw Conversion

For a stock of $n_{a, t}$ totoaba cultivated for *a* years in year *t* to weight $w_{a, t}$ for a total round weight of $x_{a, t}$, maw yield $y_{a, t}$ depends on wet maw yield ratio $c^{maw}_{a, t}$ and dry yield ratio $k$.

$y^{maw}_{a, t} = w_{a, t}n_{a, t}c^{maw}_{a, t}k^{maw}_{dry}$

Variable   | Definition
---------- | --------------------------------
$y^{maw}$  | Cohort Dry Maw Yield (Kilograms)
*w*        | Individual Round Weight (Kilograms)
*n*        | Cohort Count
$c^{maw}$  | Yield of maw from round weight.
$k^{maw}$  | Yield of dry maw from wet maw.

```{r wm_function}

fn_wm = function(w, n, c, k){ymaw = w * n * c * k
                             return(ymaw)}

```

#####Maw-Price Conversion

Plug the market model in here.

```{r mp_function}

#fn_mp = function(w, b0, bw, bq, q, bc, c){pmaw = b0 + w ^ bw + bq * q + bc * c}
fn_mp = function(w, b0, b){pmaw = b0 + w^b
                           return(pmaw)}

```

#####Maw-Revenue Conversion

Fix from regression specification. See Maw-Price Conversion.

For a dry maw yield $y^{maw}$ in kilograms, revenue depends on price.

$R^{maw}_{a, t} = x_{a, t}/n_{a, t} * (\beta_0 + \beta_{g}(x_{a, t}/n_{a, t}))$

```{r mr_function}

fn_mr = function(ymaw, pmaw){rmaw = ymaw * pmaw
                             return(rmaw)}

```

#####Round-Revenue Conversion

For a stock of *n* totoaba cultivated for *a* years in year *t* for an individual round weight of $w_{a, t}$, revenue depends on price.

$R^{round}_{a, t} = w_{a, t} * n_{a, t} * p^{round}$

```{r wr_function}

fn_fr = function(w, n, pround){rround = w * n * pround
                               return(rround)}

```

#####Feed Conversion Function

Check in with Goto. Fix.

```{r fcr_function}

#fn_fcr = function(w, fcr){}

```


#####No-Harvest Cost

Fix FCR, then fix this.

```{r c_stock}

# Feed costs for a cohort.

fn_ch0 = function(t, cstock, n){ch0 = (10000000 * t ^ cstock + 100000000) * n
                                return(ch0)}#{cstock = ccoeff * a ^ cexp - cintercept}

```


#####Harvest Cost

Cost of restocking a cage after harvest. USD?

```{r c_restock}

# Cost of fry plus overhead.

#fn_ch1 = function(){}

```


#####Single Run, No-Harvest Demo

```{r demo_noharvest}

t = seq(0, 25)
l = fn_vb(1465.3822, 0.1280, t, -0.2805)
w = fn_lw(0.000015491, l, 2.92167)
ymaw = fn_wm(w, 1, 0.40, 0.02)
pmaw = fn_mp(w, 25, 1.75)
rmaw = fn_mr(ymaw, pmaw)
rround = fn_fr(w, 1, 50000)
r = rround + rmaw
c =  10000000 * t ^ 2.15 + 100000000

demo_h0 = data.frame(t, r, c)

demo_h0 = melt(demo_h0, id = 1)

ggplot(demo_h0, aes(t, value, colour = variable)) +
  geom_path()


```


#####Single Run, Harvest Demo

```{r demo_harvest, eval = FALSE, include = FALSE}

# Duplicating structure from fishery demo - do not run without changes.

# Define parameters for each low-level function to easily run the high-level function.
var = c("start", 
        "end", 
        "linf", 
        "k",
        "t0", 
        "a", 
        "b", 
        "n0", 
        "yround", 
        "ywet", 
        "b0", 
        "b1",
        "pround", 
        #"c_coeff",
        #"c_exp",
        "c_stock",
        "c_restock",
        "disc")


par = c(1, 
        25, 
        1465, 
        0.1280, 
        -0.2805,
        0.000015491,
        2.92167,
        1,
        0.4,
        0.02,
        25,
        1.75,
        5000,
        #10000,
        #2.00,
        2.15,
        2000,
        0.95)

fun = c(rep("All", 2), 
        rep("Age-Length", 3),
        rep("Length-Weight", 2),
        rep("Weight-Maw", 3),
        rep("Maw-Price", 2),
        "Weight-Revenue (Round)",
        #rep("No-Harvest Cost", 2), 
        "No-Harvest Cost",
        "Harvest Cost",
        "Discount Factor")

num = seq(1, length(var))

tab = data.frame(num, fun, var, par)

kable(tab)

```

```{r whatever}
#q_aq = function(r, k, q, p, c, eta, x0, e0, start, end){
#                     x = as.numeric(vector(length = (end - start)))
#                     x[1] = x0
#                     e = as.numeric(vector(length = (end - start)))
#                     e[1] = e0
#                     T = length(seq(start, end))
#                     t = seq(start, end)
#            for (i in 2:T){x[i] = x[i-1] * ( 1 + r - r * x[i-1] / k - q * e[i-1])
#                           e[i] = e[i-1] * ( 1 + eta * ( p * q * x[i-1] - c))}
#                     return(x)}

# Define a function for aquaculture output over time for one cage.
aq = function(par){t = as.numeric(vector(length = par[2]))
                   a0 = as.numeric(vector(length = par[2]))
                   a1 = as.numeric(vector(length = par[2]))

                   h = as.numeric(vector(length = par[2]))
                   hinv = as.numeric(vector(length = par[2]))
                   
                   l0 = as.numeric(vector(length = par[2]))
                   w0 = as.numeric(vector(length = par[2]))
                   n0 = as.numeric(vector(length = par[2]))
                   y0 = as.numeric(vector(length = par[2]))
                   n0 = as.numeric(vector(length = par[2]))
                   p0 = as.numeric(vector(length = par[2]))
                   rmaw0 = as.numeric(vector(length = par[2]))
                   rround0 = as.numeric(vector(length = par[2]))
                   r0 = as.numeric(vector(length = par[2]))
                   c0 = as.numeric(vector(length = par[2]))
                   
                   l1 = as.numeric(vector(length = par[2]))
                   w1 = as.numeric(vector(length = par[2]))
                   n1 = as.numeric(vector(length = par[2]))
                   y1 = as.numeric(vector(length = par[2]))
                   n1 = as.numeric(vector(length = par[2]))
                   p1 = as.numeric(vector(length = par[2]))
                   rmaw1 = as.numeric(vector(length = par[2]))
                   rround1 = as.numeric(vector(length = par[2]))
                   r1 = as.numeric(vector(length = par[2]))
                   c1 = as.numeric(vector(length = par[2]))                   
                  
                   t[1] = par[1]
                   a0[1] = t[1]
                   a1[1] = a0[1] + 1
                   
                   h[1] = 0
                   hinv[1] = 1
                   
                   l0[1] = fn_vb(par[3], par[4], t[1], par[5])
                   w0[1] = fn_lw(par[6], l0[1], par[7])
                   n0[1] = par[8]
                   y0[1] = fn_wm(w0[1], n0[1], par[9], par[10])
                   p0[1] = fn_mp(w0[1], par[11], par[12])
                   rmaw0[1] = y0[1] * p0[1]
                   rround0[1] = w0[1] * par[13]
                   r0[1] = (rmaw0[1] + rround0[1])
                   c0[1] = 0 #fn_ch0(w[1], par[14], n[1])

                   l1[1] = fn_vb(par[3], par[4], 2, par[5])
                   w1[1] = fn_lw(par[6], l1[1], par[7])
                   n1[1] = par[8]
                   y1[1] = fn_wm(w1[1], n1[1], par[9], par[10])
                   p1[1] = fn_mp(w1[1], par[11], par[12])
                   rmaw1[1] = y1[1] * p1[1]
                   rround1[1] = w1[1] * par[13]
                   r1[1] = (rmaw1[1] + rround1[1]) * h[1]
                   c1[1] = 0 #fn_ch0(w[1], par[14], n[1])                   
                                     
                   for(i in 2:par[2]){
                     t[i] = t[i - 1] + 1
                     h[i] = ifelse(r0[i] > (par[16] * (r1[i])), 1, 0)
                     hinv[i] = (h[i] - 1) ^ 2
                     
                     a0[i] = a0[i - 1] * hinv[i - 1] + 1
                     a1[i] = a0[i] + 1
                     
                     l0[i] = fn_vb(par[3], par[4], a0[i], par[5])
                     w0[i] = fn_lw(par[6], l0[i], par[7])
                     n0[i] = par[8]
                     y0[i] = fn_wm(w0[i], n0[i], par[9], par[10])
                     p0[i] = fn_mp(w0[i], par[11], par[12])
                     rmaw0[i] = y0[i] * p0[i]                         # Fix yield-revenue function for maw.
                     rround0[i] = fn_fr(w0[i], n0[i], par[13])
                     r0[i] = rmaw0[i] + rround0[i]
                     c0[i] = fn_ch0(a0[i], par[14], n0[i]) # * hinv[i] + par[15] * h[i]
                     
                     l1[i] = fn_vb(par[3], par[4], a1[i], par[5])
                     w1[i] = fn_lw(par[6], l1[i], par[7])
                     n1[i] = par[8]
                     y1[i] = fn_wm(w1[i], n1[i], par[9], par[10])
                     p1[i] = fn_mp(w1[i], par[11], par[12])
                     rmaw1[i] = y1[i] * p1[i]                         # Fix yield-revenue function for maw.
                     rround1[i] = fn_fr(w1[i], n1[i], par[13])
                     r1[i] = rmaw1[i] + rround1[i]
                     c1[i] = fn_ch0(a1[i], par[14], n1[i]) # * hinv[i] + par[15] * h[i]
                     
                     r[i] = r0[i] * h[i]
                     c[i] = c0[i] * hinv[i] + par[15] * h[i] 
                     
                     }
                    
                    output = tibble(t, h, r, c)

                  return(output)}

output = aq(par)

#trim = tibble(output$r, output$c)

#use = melt(trim, id = 1)

#colnames(use) = c("t", "var", "val")

#ggplot(use, aes(t, val, colour = var)) +
  #geom_path()

```

